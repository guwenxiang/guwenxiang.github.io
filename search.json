[{"title":"公司为什么不让写sql","url":"/2021/06/12/我不写sql的原因/","content":"\n# 开始\n前几天有个同事告诉我说，他发现有个外包人员在他负责的项目里下毒，写了一堆让人烦躁的sql，改都改不掉，一开始就跟那人说了不要写复杂sql不要写复杂sql，还是写了，妈的，气死了。\n<!--more-->\n为什么同事这么火大，用脚想也知道，复杂的sql让人难以维护，但是仅仅是难以维护这么简单吗？显然不是，真相远远没有你想象的那么简单。\n\n事实上，公司几乎都让开发人员用orm单表查询，然后在代码中组装，禁止开发人员写联表sql查询。\n\n下面我来分析一波：\n\n# 对比\n## 关联查询\n在实际项目开发中，前端一个列表要展示的数据往往不是来源于单表，所以我们经常要关联多表进行查询，类似下面这样：\n\n```\nselect a.id,a.staffName,b.orgName,c.roleName\nfrom\nstaff a \njoin org b on a.org_id = b.id\njoin role c on a.role_id = c.id\nwhere a.name = \"喝水\"\n```\n## 单表查询+代码层逻辑组装\n但是，我们也可以分三次单表查询，在代码中组装前端需要展示的字段。伪代码：\n\n```\n// 1.先按条件过滤查询staff\nselect * from staff where name = \"喝水\";\n// 2.从步骤1查询的结果中拿到org_id和role_id的集合，\n比如org_id的集合为（1，2），role_id的集合为（1，2，3）\n//3.单表查询org。并得到map<orgId,orgName>\nselect * from org where id in （1,2）;\n//4.单表查询role。得到map<roleId,roleName>\nselect * from role where id in （1,2,3）;\n//5.遍历步骤1的集合，冗余前端需要展示的orgName和roleName字段\n\n```\n\n表面看起来，单表查询+代码层逻辑组装的方式，不但查询了三次数据库，代码层还多了组装逻辑的代码。你肯定会问，这不是复杂化了吗？其实这种方式有许多好处：\n\n## 好处\n\n## 1.代码复用\n关联查询的sql基本没法复用，但是拆分成单表查询，就像是一个个积木，其他地方需要都可以复用这段代码。\n## 2.利于后续维护\n上面的业务场景可能还看不出来，如果关联查询很复杂，写的sql可读性必将很差，过了一段时间自己都会看不懂，更不用说后续接手你的兄弟。\n\n再一个后续业务如果变动，导致表的结构发生变化，原先写的联表查询 sql 也会变得不可用。但是我们如果是使用单表查询，这时候只需要修改其中一个查询，非常利于维护。\n## 3.效率\n实际上 mysql 并不推荐使用join和子查询去实现复杂查询。\n\njoin联表查询，会自动优化为小表驱动大表，通过索引字段进行关联。如果表数据量较小的话效率还是可以的。\n\n多表关联查询是笛卡尔乘积的方式，数据量一旦上去，需要检索的数据是以几何倍上升的。另外多表关联查询的索引设计也要好好考虑，如果索引设计的不合理，大数据量下的多表关联查询，很可能让数据库拉垮。\n\n相比之下，用单表查询+代码层逻辑组装的方式，业务逻辑更清晰，优化维护更方便，单表索引的设计也更简单，大数据量下的查询效率更高。如此说来，多几行代码，多几次数据库查询可以换取这些优点，还是挺不错的。\n\n子查询就更不用谈，效率极差。因为执行子查询时，mysql 需要创建临时表，查询完成后再删除临时表，这里多了一个创建和删除临时表的步骤，所以子查询的效率会受到影响。\n## 4.可扩展\n当数据量大到一定程度，join 查询不利于分库分表，目前 mysql 的分布式中间件,对于跨库 join 的表现来看并不好。\n\n而拆分为单表查询+代码层做冗余处理，可以更容易对数据库进行分库分表，更容易做到高性能和可扩展。\n\n# 总结\n一个系统的瓶颈往往是出在数据库上，所以不要在数据库中做业务逻辑处理，建议数据库只是作为数据存储的工具。\n\n\n\n\n\n\n\n","tags":["mybatis","架构"],"categories":["mybatis"]},{"title":"如何保证 api 接口安全","url":"/2021/06/11/api的安全性/","content":"\n### 一、摘要 \n\n在实际的业务开发过程中，我们常常会碰到需要与第三方互联网公司进行技术对接，例如支付宝支付对接、微信支付对接、高德地图查询对接等等服务，如果你是一个创业型互联网公司，大部分可能都是对接别的公司api接口。\n<!--more-->\n当你的公司体量上来了，这个时候可能有一些公司开始找你进行技术对接了，转变成由你来提供api接口，那这个时候，我们应该如何设计并保证API接口安全呢？\n\n### 二、方案介绍 \n\n最常用的方案，主要有两种：\n\n *  token方案\n *  接口签名\n\n#### 2.1、token方案 \n\n其中 token 方案，是一种在web端使用最广的接口鉴权方案，我记得在之前写过一篇《手把手教你，使用JWT实现单点登录》的文章，里面介绍的比较详细，有兴趣的朋友可以看一下，没了解的也没关系，我们在此简单的介绍一下 token 方案。\n\n![pic_ba1bdd5c.png](https://www.liangtengyu.com:9998/images/pic_ba1bdd5c.png)\n\n从上图，我们可以很清晰的看到，token 方案的实现主要有以下几个步骤：\n\n *  1、用户登录成功之后，服务端会给用户生成一个唯一有效的凭证，这个有效值被称为token\n *  2、当用户每次请求其他的业务接口时，需要在请求头部带上token\n *  3、服务端接受到客户端业务接口请求时，会验证token的合法性，如果不合法会提示给客户端；如果合法，才会进入业务处理流程。\n\n在实际使用过程中，当用户登录成功之后，生成的token存放在redis中时是有时效的，一般设置为2个小时，过了2个小时之后会自动失效，这个时候我们就需要重新登录，然后再次获取有效token。\n\ntoken方案，是目前业务类型的项目当中使用最广的方案，而且实用性非常高，可以很有效的防止黑客们进行抓包、爬取数据。\n\n但是 token 方案也有一些缺点！最明显的就是与第三方公司进行接口对接的时候，当你的接口请求量非常大，这个时候 token 突然失效了，会有大量的接口请求失败。\n\n这个我深有体会，我记得在很早的时候，跟一家中、大型互联网公司进行联调的时候，他们提供给我的接口对接方案就是token方案，当时我司的流量高峰期时候，请求他们的接口大量报错，原因就是因为token失效了，当token失效时，我们会调用他们刷新token接口，刷新完成之后，在token失效与重新刷新token这个时间间隔期间，就会出现大量的请求失败的日志，因此在实际API对接过程中，我不推荐大家采用 token方案。\n\n#### 2.2、接口签名 \n\n接口签名，顾名思义，就是通过一些签名规则对参数进行签名，然后把签名的信息放入请求头部，服务端收到客户端请求之后，同样的只需要按照已定的规则生产对应的签名串与客户端的签名信息进行对比，如果一致，就进入业务处理流程；如果不通过，就提示签名验证失败。\n\n![pic_73078ba4.png](https://www.liangtengyu.com:9998/images/pic_73078ba4.png)\n\n在接口签名方案中，主要有四个核心参数：\n\n *  1、appid表示应用ID，其中与之匹配的还有appsecret，表示应用密钥，用于数据的签名加密，不同的对接项目分配不同的appid和appsecret，保证数据安全\n *  2、timestamp 表示时间戳，当请求的时间戳与服务器中的时间戳，差值在5分钟之内，属于有效请求，不在此范围内，属于无效请求\n *  3、nonce 表示临时流水号，用于防止重复提交验证\n *  4、signature 表示签名字段，用于判断接口请求是否有效。\n\n其中签名的生成规则，分两个步骤：\n\n *  第一步：对请求参数进行一次md5加密签名\n\n```java\n//步骤一\nString 参数1 = 请求方式 + 请求URL相对地址 + 请求Body字符串;\nString 参数1加密结果= md5(参数1)\n```\n\n *  第二步：对第一步签名结果，再进行一次md5加密签名\n\n```java\n//步骤二\nString 参数2 = appsecret + timestamp + nonce + 参数1加密结果;\nString 参数2加密结果= md5(参数2)\n```\n\n参数2加密结果，就是我们要的最终签名串。\n\n接口签名方案，尤其是在接口请求量很大的情况下，依然很稳定。\n\n换句话说，你可以将接口签名看作成对token方案的一种补充。\n\n但是如果想把接口签名方案，推广到前后端对接，答案是：不适合。\n\n因为签名计算非常复杂，其次，就是容易泄漏appsecret！\n\n说了这么多，下面我们就一起来用程序实践一下吧！\n\n### 二、程序实践 \n\n#### 2.1、token方案 \n\n就像上文所说，token方案重点在于，当用户登录成功之后，我们只需要生成好对应的token，然后将其返回给前端，在下次请求业务接口的时候，需要把token带上。\n\n具体的实践，也可以分两种：\n\n *  第一种：采用uuid生成token，然后将token存放在redis中，同时设置有效期2哥小时\n *  第二种：采用JWT工具来生成token，这种token是可以跨平台的，天然支持分布式，其实本质也是采用时间戳+密钥，来生成一个token。\n\n下面，我们介绍的是第二种实现方式。\n\n首先，编写一个jwt 工具。\n\n```java\npublic class JwtTokenUtil {\n    //定义token返回头部\n    public static final String AUTH_HEADER_KEY = \"Authorization\";\n    //token前缀\n    public static final String TOKEN_PREFIX = \"Bearer \";\n    //签名密钥\n    public static final String KEY = \"q3t6w9z$C&F)J@NcQfTjWnZr4u7x\";\n    //有效期默认为 2hour\n    public static final Long EXPIRATION_TIME = 1000L*60*60*2;\n    /**\n     * 创建TOKEN\n     * @param content\n     * @return\n     */\n    public static String createToken(String content){\n        return TOKEN_PREFIX + JWT.create()\n                .withSubject(content)\n                .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TIME))\n                .sign(Algorithm.HMAC512(KEY));\n    }\n    /**\n     * 验证token\n     * @param token\n     */\n    public static String verifyToken(String token) throws Exception {\n        try {\n            return JWT.require(Algorithm.HMAC512(KEY))\n                    .build()\n                    .verify(token.replace(TOKEN_PREFIX, \"\"))\n                    .getSubject();\n        } catch (TokenExpiredException e){\n            throw new Exception(\"token已失效，请重新登录\",e);\n        } catch (JWTVerificationException e) {\n            throw new Exception(\"token验证失败！\",e);\n        }\n    }\n}\n```\n\n接着，我们在登录的时候，生成一个token，然后返回给客户端。\n\n```java\n@RequestMapping(value = \"/login\", method = RequestMethod.POST, produces = {\"application/json;charset=UTF-8\"})\npublic UserVo login(@RequestBody UserDto userDto, HttpServletResponse response){\n    //...参数合法性验证\n    //从数据库获取用户信息\n    User dbUser = userService.selectByUserNo(userDto.getUserNo);\n    //....用户、密码验证\n    //创建token，并将token放在响应头\n    UserToken userToken = new UserToken();\n    BeanUtils.copyProperties(dbUser,userToken);\n    String token = JwtTokenUtil.createToken(JSONObject.toJSONString(userToken));\n    response.setHeader(JwtTokenUtil.AUTH_HEADER_KEY, token);\n    //定义返回结果\n    UserVo result = new UserVo();\n    BeanUtils.copyProperties(dbUser,result);\n    return result;\n}\n```\n\n最后，编写一个统一拦截器，用于验证客户端传入的token是否有效。\n\n```java\n@Slf4j\npublic class AuthenticationInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        // 从http请求头中取出token\n        final String token = request.getHeader(JwtTokenUtil.AUTH_HEADER_KEY);\n        //如果不是映射到方法，直接通过\n        if(!(handler instanceof HandlerMethod)){\n            return true;\n        }\n        //如果是方法探测，直接通过\n        if (HttpMethod.OPTIONS.equals(request.getMethod())) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            return true;\n        }\n        //如果方法有JwtIgnore注解，直接通过\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\n        Method method=handlerMethod.getMethod();\n        if (method.isAnnotationPresent(JwtIgnore.class)) {\n            JwtIgnore jwtIgnore = method.getAnnotation(JwtIgnore.class);\n            if(jwtIgnore.value()){\n                return true;\n            }\n        }\n        LocalAssert.isStringEmpty(token, \"token为空，鉴权失败！\");\n        //验证，并获取token内部信息\n        String userToken = JwtTokenUtil.verifyToken(token);\n        //将token放入本地缓存\n        WebContextUtil.setUserToken(userToken);\n        return true;\n    }\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        //方法结束后，移除缓存的token\n        WebContextUtil.removeUserToken();\n    }\n}\n```\n\n在生成token的时候，我们可以将一些基本的用户信息，例如用户ID、用户姓名，存入token中，这样当token鉴权通过之后，我们只需要通过解析里面的信息，即可获取对应的用户ID，可以省下去数据库查询一些基本信息的操作。\n\n同时，使用的过程中，尽量不要存放敏感信息，因为很容易被黑客解析！\n\n#### 2.2、接口签名 \n\n同样的思路，站在服务端验证的角度，我们可以先编写一个签名拦截器，验证客户端传入的参数是否合法，只要有一项不合法，就提示错误。\n\n具体代码实践如下：\n\n```java\npublic class SignInterceptor implements HandlerInterceptor {\n\n    @Autowired\n    private AppSecretService appSecretService;\n\n    @Autowired\n    private RedisUtil redisUtil;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        //appId验证\n        final String appId = request.getHeader(\"appid\");\n        if(StringUtils.isEmpty(appId)){\n            throw new CommonException(\"appid不能为空\");\n        }\n        String appSecret = appSecretService.getAppSecretByAppId(appId);\n        if(StringUtils.isEmpty(appSecret)){\n            throw new CommonException(\"appid不合法\");\n        }\n        //时间戳验证\n        final String timestamp = request.getHeader(\"timestamp\");\n        if(StringUtils.isEmpty(timestamp)){\n            throw new CommonException(\"timestamp不能为空\");\n        }\n        //大于5分钟，非法请求\n        long diff = System.currentTimeMillis() - Long.parseLong(timestamp);\n        if(Math.abs(diff) > 1000 * 60 * 5){\n            throw new CommonException(\"timestamp已过期\");\n        }\n        //临时流水号，防止重复提交\n        final String nonce = request.getHeader(\"nonce\");\n        if(StringUtils.isEmpty(nonce)){\n            throw new CommonException(\"nonce不能为空\");\n        }\n        //验证签名\n        final String signature = request.getHeader(\"signature\");\n        if(StringUtils.isEmpty(nonce)){\n            throw new CommonException(\"signature不能为空\");\n        }\n        final String method = request.getMethod();\n        final String url = request.getRequestURI();\n        final String body = StreamUtils.copyToString(request.getInputStream(), Charset.forName(\"UTF-8\"));\n        String signResult = SignUtil.getSignature(method, url, body, timestamp, nonce, appSecret);\n        if(!signature.equals(signResult)){\n            throw new CommonException(\"签名验证失败\");\n        }\n        //检查是否重复请求\n        String key = appId + \"_\" + timestamp + \"_\" + nonce;\n        if(redisUtil.exist(key)){\n            throw new CommonException(\"当前请求正在处理，请不要重复提交\");\n        }\n        //设置5分钟\n        redisUtil.save(key, signResult, 5*60);\n        request.setAttribute(\"reidsKey\",key);\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)\n            throws Exception {\n        //请求处理完毕之后，移除缓存\n        String value = request.getAttribute(\"reidsKey\");\n        if(!StringUtils.isEmpty(value)){\n            redisUtil.remove(value);\n        }\n    }\n\n}\n```\n\n签名工具类`SignUtil`：\n\n```java\npublic class SignUtil {\n\n    /**\n     * 签名计算\n     * @param method\n     * @param url\n     * @param body\n     * @param timestamp\n     * @param nonce\n     * @param appSecret\n     * @return\n     */\n    public static String getSignature(String method, String url, String body, String timestamp, String nonce, String appSecret){\n        //第一层签名\n        String requestStr1 = method + url + body + appSecret;\n        String signResult1 = DigestUtils.md5Hex(requestStr1);\n        //第二层签名\n        String requestStr2 = appSecret + timestamp + nonce + signResult1;\n        String signResult2 = DigestUtils.md5Hex(requestStr2);\n        return signResult2;\n    }\n}\n```\n\n签名计算，可以换成`hamc`方式进行计算，思路大致一样。\n\n### 三、小结 \n\n上面介绍的token和接口签名方案，对外都可以对提供的接口起到保护作用，防止别人篡改请求，或者模拟请求。\n\n但是缺少对数据自身的安全保护，即请求的参数和返回的数据都是有可能被别人拦截获取的，而这些数据又是明文的，所以只要被拦截，就能获得相应的业务数据。\n\n对于这种情况，推荐大家对请求参数和返回参数进行加密处理，例如RSA、AES等加密工具。\n\n同时，在生产环境，采用`https`方式进行传输，可以起到很好的安全保护作用！\n","tags":["mybatis","架构"],"categories":["mybatis"]},{"title":"我的 MySQL 经验之谈","url":"/2021/06/05/mysql开发实践/","content":"# 表结构设计\n\n昨天有个粉丝问我关于 MySQL 在实际企业中的运用以及要注意哪些问题，今天我来总结一下：\n<!--more-->\n## 1.主键\n\n在实际项目中，主键id推荐使用数据库自增ID（类型为bigint）和雪花算法生成的随机ID。\n\n业务量小，采用自增ID；业务量大，推荐采用雪花算法。\n\n使用自增id的缺点：\n\n1、自增id如果暴露，容易被人发现规律\n\n2、对于高并发的情况下，innodb引擎在按主键进行插入的时候会造成明显的锁争用，主键的上界会成为争抢的热点。\n\n3、单表数据量达到一定程度后要分库分表，导致ID重复，解决起来比较麻烦\n\n## 2.外键\n不要使用外键与其它表进行关联，避免高并发场景的性能问题\n\n1、外键是极影响并发性能的，因为当存在外键约束的时候，MySQL会进行即时检查，每次insert和update都要要去扫描此记录是否满足\n\n2、耦合度高，后期很难进行分库分表\n## 3.合适的字段类型和长度\n\n数据库的资源是很宝贵的，合适的字段类型和长度，不但节约数据库表空间和节约索引存储空间，更重要的是提升检索速度\n\n1、对于固定长度的坚决使用char/tiyint等类型\n\n2、对于不固定长度但是确定了总长度的使用varchar类型\n\n3、不要用varchar/char 存储长字符串,直接用text。并且让长字符串拆分到另一个表，保持主表尽量瘦小\n\n## 4.字段冗余\n允许适当冗余其他表的字段，以提高查询性能，但必须考虑数据一致而且不要冗余过长的字段\n\n## 5.字段默认值\n避免将字段默认值设为null\n\n对MySQL来说，会使得索引、索引统计和值的比较都更加复杂\nNULL会参与字段比较，所以对效率有一部分影响，比如!=, <>等\n\n# 索引设计\n\n## 1.覆盖索引\n对于count和group场景，请使用覆盖索引，提高查询性能。\n\n索引就像是一本书的目录，如果查询的内容都只和目录上的内容有关，那mysql只要扫描索引结构就能得到查询结果，比如我给student表增加了个索引：\n\n```\nALTER TABLE `student` ADD INDEX index_name (name,gender);\n```\n用到索引覆盖的sql语句：\n\n```\nselect name,gender from student;\nselect name,gender from student where name='不高兴就喝水' and gender=1;\nselect name,gender from student group by name,gender;\nselect name,gender,count(1) from student group by name,gender;\nselect name from student group by name;\nselect name ,count(1) from student group by name;\n\n```\n## 2.复合索引\n设计索引的时候尽量使用复合索引，并将区分度高的字段放在前面\n\n那么什么是区分度高的字段呢？\n\n执行如下语句，假设查询结果为 0.9,0.1,1000，可以看到name列的选择性最高，因此将其作为联合索引的第一列，即建立(name, gender)的联合索引\n```\nselect count(distinct name) / count(*), count(distinct gender) / count(*), count(*) from student\n```\n根据索引最左匹配原则，能够触发这个联合索引的sql语句是：\n\n```\nselect name,gender from student where name=\"不高兴就喝水\" and gender=1\nselect name,gender from student where gender=1 and name=\"不高兴就喝水\" ;\nselect name,gender from student where name=\"不高兴就喝水\";\nselect name,gender from student where age=18 name='不高兴就喝水';\n\n```\n## 3.索引失效\n以下几个操作会引起索引失效：\n\n1.在索引列上做计算、函数、转换类型等操作\n\n2.违反最左匹配原则\n\n3.like以通配符开头（例如：'%喝水'）\n\n4.防止隐式转换，比如：索引的字段为字符串类型，查询的时候不加单引号（ name为vachar类型，查询的时候 where name = 1）\n\n5.or连接，等等..\n\n## 4.唯一索引\n对于需要保证表中唯一的字段，即使在应用层做了校验，也必须建立唯一索引\n\n注意：在性能上，唯一索引在查询时的性能要比非聚集索引高，但是在插入与更新时要比非聚集索引低\n\n\n## 5.长字符索引\n在长度较长的字段上建立索引时，必须指定索引长度，没必要对全字段建立索引\n\n索引的长度与区分度是一对矛盾体，一般对于字符串类型的字段，设置索引的长度为 20，区分度会高达 90%以上，可以使用以下sql来确定区分度：\n\n```\nselect count(distinct left(列名,索引长度)) / count(*) from 表名\n```\n# 语句设计\n## 1.逻辑删除\n大多时候，删除操作应该采用逻辑删除，不能物理删除。\n我们必须承认数据是无价之宝，在很多时候，数据的价值是远远高于人工成本的。\n\n正式环境的数据库账号往往是没有delete权限的，避免误操作，删库跑路等等\n\n并且update操作比delete性能高\n\n## 2.in的使用\n虽然in的数量 MySQL 并没有做具体的限制，但对整个 SQL 语句的长度做了限制。 不要进行 in 大量数据集合的操作，若实在无法避免，可以分批次查询，一次in 一定数量集。 \n\n\n## 3.inner join的使用\n当我们使用关联查询的时候，用小表驱动大表的方式效率会提升很多。而 inner join 会自动的进行小表驱动大表的优化\n\n## 4.触发器和存储过程\n避免使用触发器和存储过程，难以调试和扩展不说，更是没有可移植性，这些边缘功能最好不用。\n\n## 5.count\nmysql5.7对count(*) 进行了优化\n\n所以现在 count( *)和count(1)的执行效率是一样的。\n\n而count(字段)因为有sql解析的过程，不仅效率会慢，而且不会对null值进行统计\n\n## 6.避免大事务\n\n大事务就是运行的时间比较长，操作的数据比较多的事务\n大事务会影响数据库的性能，应当尽量把大事务拆成若干个小事务，禁止写过于复杂的sql语句，除了造成大事务不说，还会让别人头大，无法维护。\n\n目前能想到的就是这，欢迎补充～\n\n","tags":["mybatis","架构"],"categories":["mybatis"]},{"title":"mybatis的架构原理","url":"/2021/05/25/mybatis架构原理/","content":"### MyBatis功能架构设计 \n<!--more-->\n\n![pic_2ba29528.png](https://www.liangtengyu.com:9998/images/pic_2ba29528.png)\n\nimage.png\n\n###### 功能架构讲解： \n\n我们把Mybatis的功能架构分为三层：\n\n(1)API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。\n\n(2)数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。\n\n(3)基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。  \n  \n\n\n### 框架架构 \n\n![pic_46f4a630.png](https://www.liangtengyu.com:9998/images/pic_46f4a630.png)\n\n###### 框架架构讲解： \n\n这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。\n\n(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。\n\n(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。\n\n(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。\n\n(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。  \n  \n\n\n### MyBatis核心类 \n\n###### 1、SqlSessionFactoryBuilder \n\n每一个MyBatis的应用程序的入口是SqlSessionFactoryBuilder。\n\n它的作用是通过XML配置文件创建Configuration对象（当然也可以在程序中自行创建），然后通过build方法创建SqlSessionFactory对象。没有必要每次访问Mybatis就创建一次SqlSessionFactoryBuilder，通常的做法是创建一个全局的对象就可以了。示例程序如下：\n\n```java\nprivate static SqlSessionFactoryBuilder sqlSessionFactoryBuilder;\nprivate static SqlSessionFactory sqlSessionFactory;\n\nprivate static void init() throws IOException {\n    String resource = \"mybatis-config.xml\";\n    Reader reader = Resources.getResourceAsReader(resource);\n    sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n    sqlSessionFactory = sqlSessionFactoryBuilder.build(reader);\n}\n```\n\n`org.apache.ibatis.session.Configuration 是mybatis初始化的核心。`\n\nmybatis-config.xml中的配置，最后会解析xml成Configuration这个类。\n\nSqlSessionFactoryBuilder根据传入的数据流(XML)生成Configuration对象，然后根据Configuration对象创建默认的SqlSessionFactory实例。\n\n###### 2、SqlSessionFactory对象由SqlSessionFactoryBuilder创建： \n\n它的主要功能是创建SqlSession对象，和SqlSessionFactoryBuilder对象一样，没有必要每次访问Mybatis就创建一次SqlSessionFactory，通常的做法是创建一个全局的对象就可以了。SqlSessionFactory对象一个必要的属性是Configuration对象，它是保存Mybatis全局配置的一个配置对象，通常由SqlSessionFactoryBuilder从XML配置文件创建。这里给出一个简单的示例：\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration PUBLIC \n   \"-//mybatis.org//DTD Config 3.0//EN\"\n   \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n   <!-- 配置别名 -->\n   <typeAliases>\n       <typeAlias type=\"org.iMybatis.abc.dao.UserDao\" alias=\"UserDao\" />\n       <typeAlias type=\"org.iMybatis.abc.dto.UserDto\" alias=\"UserDto\" />\n   </typeAliases>\n    \n   <!-- 配置环境变量 -->\n   <environments default=\"development\">\n       <environment id=\"development\">\n           <transactionManager type=\"JDBC\" />\n           <dataSource type=\"POOLED\">\n               <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\n               <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/iMybatis?characterEncoding=GBK\" />\n               <property name=\"username\" value=\"iMybatis\" />\n               <property name=\"password\" value=\"iMybatis\" />\n           </dataSource>\n       </environment>\n   </environments>\n   \n   <!-- 配置mappers -->\n   <mappers>\n       <mapper resource=\"org/iMybatis/abc/dao/UserDao.xml\" />\n   </mappers>\n   \n</configuration>\n```\n\n###### 3、SqlSession \n\nSqlSession对象的主要功能是完成一次数据库的访问和结果的映射，它类似于数据库的session概念，由于不是线程安全的，所以SqlSession对象的作用域需限制方法内。SqlSession的默认实现类是DefaultSqlSession，它有两个必须配置的属性：Configuration和Executor。Configuration前文已经描述这里不再多说。SqlSession对数据库的操作都是通过Executor来完成的。\n\nSqlSession ：默认创建DefaultSqlSession 并且开启一级缓存，创建执行器 、赋值。\n\nSqlSession有一个重要的方法getMapper，顾名思义，这个方式是用来获取Mapper对象的。什么是Mapper对象？根据Mybatis的官方手册，应用程序除了要初始并启动Mybatis之外，还需要定义一些接口，接口里定义访问数据库的方法，存放接口的包路径下需要放置同名的XML配置文件。\n\nSqlSession的getMapper方法是联系应用程序和Mybatis纽带，应用程序访问getMapper时，Mybatis会根据传入的接口类型和对应的XML配置文件生成一个代理对象，这个代理对象就叫Mapper对象。应用程序获得Mapper对象后，就应该通过这个Mapper对象来访问Mybatis的SqlSession对象，这样就达到里插入到Mybatis流程的目的。\n\n```java\nSqlSession session= sqlSessionFactory.openSession();  \nUserDao userDao = session.getMapper(UserDao.class);  \nUserDto user = new UserDto();  \nuser.setUsername(\"iMybatis\");  \nList<UserDto> users = userDao.queryUsers(user);  \n\npublic interface UserDao {\n    public List<UserDto> queryUsers(UserDto user) throws Exception;\n}\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">  \n<mapper namespace=\"org.iMybatis.abc.dao.UserDao\">  \n    <select id=\"queryUsers\" parameterType=\"UserDto\" resultType=\"UserDto\"  \n        useCache=\"false\">  \n        <![CDATA[ \n        select * from t_user t where t.username = #{username} \n        ]]>  \n    </select>  \n</mapper>\n```\n\n###### 4、Executor \n\nExecutor对象在创建Configuration对象的时候创建，并且缓存在Configuration对象里。Executor对象的主要功能是调用StatementHandler访问数据库，并将查询结果存入缓存中（如果配置了缓存的话）。\n\n###### 5、StatementHandler \n\nStatementHandler是真正访问数据库的地方，并调用ResultSetHandler处理查询结果。\n\n###### 6、ResultSetHandler \n\n处理查询结果。  \n  \n\n\n### MyBatis成员层次&职责 \n\n![pic_a7986057.png](https://www.liangtengyu.com:9998/images/pic_a7986057.png)\n\nimage.png\n\n1.  SqlSession 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能\n2.  Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护\n3.  StatementHandler 封装了JDBC Statement操作，负责对JDBCstatement的操作，如设置参数、将Statement结果集转换成List集合。\n4.  ParameterHandler 负责对用户传递的参数转换成JDBC Statement 所需要的参数\n5.  ResultSetHandler \\*负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；\n6.  TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换\n7.  MappedStatement MappedStatement维护了一条<select|update|delete|insert>节点的封\n8.  SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回\n9.  BoundSql 表示动态生成的SQL语句以及相应的参数信息\n10. Configuration MyBatis所有的配置信息都维持在Configuration对象之中\n\n来源：https://www.jianshu.com/p/15781ec742f2","tags":["mybatis","架构"],"categories":["mybatis"]},{"title":"JVM修炼《1》之java类的加载机制","url":"/2021/05/08/java虚拟机1/","content":"当程序使用某个类时，如果该类还没被初始化，加载到内存中，则系统会通过加载、连接、初始化三个过程来对该类进行初始化。该过程就被称为类的初始化。\n<!--more-->\n# 1.什么是类加载\n类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。\n\n类加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。\n\n![WechatIMG207.png](https://i.loli.net/2021/05/08/inIJwKNvlWEA5jG.png)\n\n类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。\n\n## 加载.class文件的方式\n\n- 从本地系统中直接加载\n- 通过网络下载.class文件\n- 从zip，jar等归档文件中加载.class文件\n- 从专有数据库中提取.class文件\n- 将Java源文件动态编译为.class文件\n\n# 2.类的生命周期\n类的生命周期如下：\n![WechatIMG208.png](https://i.loli.net/2021/05/08/3bLJwQ4MGFzYKXt.png)\n\n其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。\n\n## 加载\n查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：\n\n- 通过一个类的全限定名来获取其定义的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。\n\n相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。\n\n加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。\n\n## 连接\n### 验证：确保被加载的类的正确性\n\n验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：\n\n**文件格式验证**：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。\n\n**元数据验证**：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。\n\n**字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n\n**符号引用验证**：确保解析动作能正确执行。\n验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n\n### 准备：为类的静态变量分配内存，并将其初始化为默认值\n\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：\n\n1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。\n\n2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。\n\n假设一个类变量的定义为：\n\n\n```\npublic static int value = 3；\n```\n\n\n那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的public static指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。\n\n这里还需要注意如下几点：\n\n对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。\n\n对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。\n\n对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。\n\n如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。\n\n3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。\n\n假设上面的类变量value被定义为： \n\n\n```\npublic static final int value = 3；\n```\n\n\n编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中\n\n### 解析：把类中的符号引用转换为直接引用\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。\n\n直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n\n### 初始化\n\n初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：\n\n①声明类变量是指定初始值\n\n②使用静态代码块为类变量指定初始值\nJVM初始化步骤\n\n1、假如这个类还没有被加载和连接，则程序先加载并连接该类\n\n2、假如该类的直接父类还没有被初始化，则先初始化其直接父类\n\n3、假如类中有初始化语句，则系统依次执行这些初始化语句\n\n类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：\n\n- 创建类的实例，也就是new的方式\n- 访问某个类或接口的静态变量，或者对该静态变量赋值\n- 调用类的静态方法\n- 反射（如Class.forName(“com.shengsiyuan.Test”)）\n- 初始化某个类的子类，则其父类也会被初始化\n- Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类\n### 结束生命周期\n在如下几种情况下，Java虚拟机将结束生命周期\n\n- 执行了System.exit()方法\n- 程序正常执行结束\n- 程序在执行过程中遇到了异常或错误而异常终止\n- 由于操作系统出现错误而导致Java虚拟机进程终止\n\n# 3.类加载器\n下面我们看这段代码：\n```\npackage cn.thinkjoy.uc.service.impl.business.recruit;\n\npublic class ClassLoaderTest {\n     public static void main(String[] args) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        System.out.println(loader);\n        System.out.println(loader.getParent());\n        System.out.println(loader.getParent().getParent());\n    }\n}\n```\n运行后输出：\n\n```\nsun.misc.Launcher$AppClassLoader@18b4aac2\nsun.misc.Launcher$ExtClassLoader@28ba21f3\nnull\n```\n从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。\n\n这几种类加载器的层次关系如下图所示：\n\n![WechatIMG209.png](https://i.loli.net/2021/05/08/U3rTBKCfuDs5lyE.png)\n\n**注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。**\n\n站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。\n\n站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：\n\n**启动类加载器**：Bootstrap ClassLoader，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。\n\n**扩展类加载器**：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。\n\n**应用程序类加载器**：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：\n\n1、在执行非置信代码之前，自动验证数字签名。\n\n2、动态地创建符合用户特定需要的定制化构建类。\n\n3、从特定的场所取得java class，例如数据库中和网络中。\n\n## JVM类加载机制\n\n**全盘负责**，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入\n\n**父类委托**，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类\n\n**缓存机制**，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效\n\n# 4.类的加载\n类加载有三种方式：\n\n1、命令行启动应用时候由JVM初始化加载\n\n2、通过Class.forName()方法动态加载\n\n3、通过ClassLoader.loadClass()方法动态加载\n\n例子：\n\n```\npackage cn.thinkjoy.uc.service.impl.business.recruit;\n\nimport sun.jvm.hotspot.HelloWorld;\n\npublic class loaderTest {\n        public static void main(String[] args) throws ClassNotFoundException { \n                ClassLoader loader = HelloWorld.class.getClassLoader();\n                System.out.println(loader); \n                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 \n                loader.loadClass(\"Test2\"); \n                //使用Class.forName()来加载类，默认会执行初始化块 \n                //Class.forName(\"Test2\"); \n                //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 \n                //Class.forName(\"Test2\", false, loader); \n        } \n}\n```\n\n```\npublic class Test2 { \n        static { \n                System.out.println(\"静态初始化块代码执行了！\"); \n        } \n}\n```\n分别切换加载方式，会有不同的输出结果。\n\nClass.forName()和ClassLoader.loadClass()区别\n\n**Class.forName()**：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；\n\n**ClassLoader.loadClass()**：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。\n\n**Class.forName(name, initialize, loader)**：带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。\n# 5.双亲委派模型\n双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n\n双亲委派机制:\n\n1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。\n\n2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。\n\n3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；\n\n4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。\nClassLoader源码分析：\n\n\n```\npublic Class<?> loadClass(String name)throws ClassNotFoundException {\n        return loadClass(name, false);\n}\n\nprotected synchronized Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {\n        // 首先判断该类型是否已经被加载\n        Class c = findLoadedClass(name);\n        if (c == null) {\n            //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载\n            try {\n                if (parent != null) {\n                     //如果存在父类加载器，就委派给父类加载器加载\n                    c = parent.loadClass(name, false);\n                } else {\n                //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)\n                    c = findBootstrapClass0(name);\n                }\n            } catch (ClassNotFoundException e) {\n             // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能\n                c = findClass(name);\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n```\n双亲委派模型意义：\n\n1.系统类防止内存中出现多份同样的字节码\n\n2.保证Java程序安全稳定运行\n# 6.自定义类加载器\n通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自ClassLoader类，从上面对loadClass方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：\n\n```\nimport java.io.*;\n\npublic class MyClassLoader extends ClassLoader {\n    private String root;\n\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = loadClassData(name);\n        if (classData == null) {\n            throw new ClassNotFoundException();\n        } else {\n            return defineClass(name, classData, 0, classData.length);\n        }\n    }\n\n    private byte[] loadClassData(String className) {\n        String fileName = root + File.separatorChar\n                + className.replace('.', File.separatorChar) + \".class\";\n        try {\n            InputStream ins = new FileInputStream(fileName);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = 0;\n            while ((length = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, length);\n            }\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getRoot() {\n        return root;\n    }\n\n    public void setRoot(String root) {\n        this.root = root;\n    }\n\n    public static void main(String[] args)  {\n\n        MyClassLoader classLoader = new MyClassLoader();\n        classLoader.setRoot(\"E:\\\\temp\");\n\n        Class<?> testClass = null;\n        try {\n            testClass = classLoader.loadClass(\"com.neo.classloader.Test2\");\n            Object object = testClass.newInstance();\n            System.out.println(object.getClass().getClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：\n\n1、这里传递的文件名需要是类的全限定性名称，即com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。\n\n2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。\n\n3、这类Test 类本身可以被 AppClassLoader类加载，因此我们不能把com/paddx/test/classloading/Test.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader加载，而不会通过我们自定义类加载器来加载。\n\n参考相关文章：\n\n[https://segmentfault.com/a/1190000005608960](https://note.youdao.com/)\n[https://blog.csdn.net/ns_code/article/details/17881581](https://note.youdao.com/)\n[https://blog.csdn.net/duoyu779553/article/details/105878755](https://note.youdao.com/)","tags":["jvm","java基础"],"categories":["jvm"]},{"title":"怎么保证数据库和缓存的一致性","url":"/2021/05/06/缓存一致性/","content":"\n# 缓存的用法\n在项目中我们经常用缓存来缓解数据库的压力：\n<!--more-->\n![4.png](https://i.loli.net/2021/05/06/TkCxneg6Xb8wz1l.png)\n\n但是对于写缓存，你知道怎么保证缓存与数据库的数据一致性吗？\n让我们来探讨一下。\n# 先更新数据库，再更新缓存\n![1.png](https://i.loli.net/2021/05/06/vPIEsakKgzhNir5.png)\n请求B是最后请求的，那么应该是他最后更新缓存为正确的数据，但是有可能请求A处理的更慢，所以请求A更新了最后的缓存。\n\n# 先删除缓存，再更新数据库\n\n先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，然后更新缓存，缓存不一致发生。如图：\n![5.png](https://i.loli.net/2021/05/06/OSJALXQ6mfpdrnh.png)\n# 延时双删\n上面的问题可以用延时双删的方案来解决，思路是，更新完数据库之后，再sleep一段时间，然后再次删除缓存。\n\nsleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。\n\n流程如下：\n![7.png](https://i.loli.net/2021/05/06/t1e3CwEA4Rj8smi.png)\n\n1. 线程1删除缓存，然后去更新数据库\n \n2. 线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存\n\n3. 线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除\n\n4. 如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值\n\n# 先更新数据库，再删除缓存\n当然，这样也会有并发问题。\n比如：\n\n![3.png](https://i.loli.net/2021/05/06/gPr6noaKz9Q7D1R.png)\n\n但是数据库读操作速度远快于写操作，所以存在脏数据的可能性为0。\n当然如果您问，如果真的存在怎么办？\n简单，双删就行了，即第一次删除缓存之后，等待一段时间重新再删一次。\n当然您如果还问，删除缓存失败了怎么办，解决方法如下：\n![8.png](https://i.loli.net/2021/05/06/yzOYQ2cDkgLGjn5.png)\n即引入消息队列，删除缓存失败的记录下来重复删除，直到成功为止。如此一来，万无一失。\n\n# 其他解决方案\n## 设置缓存过期时间\n每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。\n\n如果对于一致性要求不是很高的情况，可以采用这种方案。\n\n这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。\n\n# 总结\n首先，我们要明确一点，缓存不是更新，而应该是删除。\n\n为什么呢？\n我们用先更新数据库，再删除缓存来举例。\n\n如果是更新的话，那就是先更新数据库，再更新缓存。\n\n举个例子：如果数据库1小时内更新了1000次，那么缓存也要更新1000次，但是这个缓存可能在1小时内只被读取了1次，那么这1000次的更新有必要吗？\n\n反过来，如果是删除的话，就算数据库更新了1000次，那么也只是做了1次缓存删除，只有当缓存真正被读取的时候才去数据库读取。\n\n删除缓存有以下两种方式：\n\n1.先删除缓存，再更新数据库。解决方案是使用延迟双删。\n\n2.先更新数据库，再删除缓存。解决方案是消息队列或者其他binlog同步，引入消息队列会带来更多的问题，并不推荐直接使用。\n\n针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就行了。","tags":["技能包","解决方案"],"categories":["解决方案"]},{"title":"《微服务设计》第12章 总结","url":"/2021/04/24/微服务设计12/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第11章 规模化微服务","url":"/2021/04/24/微服务设计11/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第10章 康威定律和系统设计","url":"/2021/04/24/微服务设计10/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第9章 安全","url":"/2021/04/24/微服务设计9/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第8章 监控","url":"/2021/04/24/微服务设计8/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第7章 测试","url":"/2021/04/24/微服务设计7/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第6章 部署","url":"/2021/04/24/微服务设计6/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第5章 分解单块系统","url":"/2021/04/24/微服务设计5/","content":"待输出\n<!--more-->","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第4章 集成","url":"/2021/04/24/微服务设计4/","content":"集成是微服务相关技术中最重要的一个。做的好，可以保持微服务的自治性，做的不好会带来灾难。\n你总提及的那个词，它的含义与你想表达的意思并不一样。\n<!--more-->\n# 1.理想的集成技术\n## 1.1避免破坏性修改\n如果在一个微服务的响应中添加一个字段，服务的消费方不应该受到影响。\n## 1.2保证API的技术无关性\n微服务之间的通信应该是与技术无关的。\n## 1.3使服务的消费方易于使用\n如果消费方使用该服务比登天还难，那么无论该微服务多漂亮都没用任何意义。但同时，易于使用的服务可能内部封装了很多细节，这会增加耦合。\n## 1.4隐藏内部实现细节\n消费方与服务方的内部细节应该是分开的，如果与细节绑定，则意味着改变服务内部的一些变化，消费方也要跟着修改，这会增加修改的成本。\n# 2.数据库共享？\n共享数据库是最快的集成方式，但这种方式应该避免。\n\n如果共享了数据库，那么外部的服务则能查看内部的实现细节，并与其绑定在一起，存储在数据库中的数据结构对所有人来说都是平等的，数据库是一个很大的共享API，那么为了不影响其他服务，必须非常小心地避免修改与其他服务相关的表结构。这样的情况下，需要做大量的回归测试来保证功能的正确性。\n\n其次，消费方与服务方的特定技术绑定在了一起，如果消费方要从关系型数据库换成非关系型数据库，那么这样是不容易实现的。这不符合低耦合的原则。\n\n最后，那么原本由服务方提供的修改，现在可以由各个消费方直接操作数据库来完成，而且每个消费方可能都会有一套自己的修改方法。这不符合高内聚的原则。\n# 3.同步与异步\n如果使用同步方式进行通信，发起方发起一个远程调用后，发起方会阻塞自己并等待整个操作的完成。\n\n异步通信对于运行时间较长的任务来说比较有用，异步的通信模型有两种。\n\n一种是请求/响应方式，这与同步的不同，它是在发起一个请求时，同时注册一个回调，当服务端操作结束之后，会调用该回调。\n\n一种是基于事件的方式，服务提供方不发起请求，而是发布一个事件，然后期待调用方接收消息，并知道该怎么做，服务提供方不需要知道该或者什么会对此做出响应，这也意味着，你可以在不影响服务提供方的情况下对该事件添加新的订阅。\n# 4.编排与协同\n假如你现在一家网站上注册账户，在注册账户系统做了下面三件事：\n\n（1）在客户的积分账户上创建一条记录\n\n（2）通过EMS系统发送一个欢迎礼包\n\n（3）向客户发送欢迎电子邮件\n\n当考虑实现时，编排是一种架构风格，它由一个中心大脑来指导并驱动整个流程。它可由客户管理这个服务来承担，在创建客户时会跟积分账户服务、电子邮件服务及EMS服务通过请求/响应的方式进行通信。客户管理服务可以对当前进行到了哪一步进行跟踪，它会检查积分账户是否创建成功、电子邮件是否发送出去、EMS包裹是否寄出。这种方式的缺点是：客户管理服务承担了太多职责，它会成为网关结构的中心和很多逻辑的起点。这样会导致少量的“上帝”服务，而与其打资产的那些服务通常会沦为贫血的CRUD服务。\n\n另一种实现的风格则是协同，它仅仅告知各个系统各自的职责，具体的实现留给他们自己。就上例而言，客户管理服务创建一个事件，邮件服务、积分服务、EMS服务会订阅这些事件并做相应的处理，如果其他的服务也关心客户创建这件事情，它们只需要简单的订阅该事件即可。这种方式能显著地消除耦合，但这需要额外做一些监控工作，以保证其正确进行。我们可以建一个跟业务流程相匹配的监控服务，分别监控每个服务。\n# 5.远程过程调用\n\nrpc带来的问题，用dubbo举例：\n- 耦合问题\n- \n刚开始使用Dubbo大家都会很容易的接受Provider和Consumer的jar包方式进行服务的管理工作。而慢慢的逐渐深入使用会逐渐的体会到Dubbo的API JAR包变成了一种约束。这样就非常间接，不明显的将Provider和Consumer绑定在一起。如果其中一方出现问题，就会造成另外一方的一些问题。\n\n- 语言锁定\n\n微服务的一个准则就是每个服务可以独立的演进，独立发展。可以通过不同的编程语言对服务进行编写。而Dubbo和类似的RPC实现方式使用Jar包的方式发布接口，那么就只能使用JVM上语言进行Jar的解析与加载工作。导致必须使用相同的语言进行rpc接口的调用。\n\n- 上下文传递\n\nHttp是一种无状态服务，那并不代表RPC必须是一种无状态服务。在Http协议通过不断的发展在协议中传递了一些有状态的上下文信息，这样可以为服务提供一些有状态的信息以便在业务处理过程中使用。而RPC是一种更加纯粹的无状态服务，它没有标准化的规范导致不可能形成完善的解决方案。在Dubbo中可以借助多种方式进行上下文的传递工作，不过实现起来比较复杂。其中包括：Dubbo 上下文信息，事件通知，协议扩展\n\n- 版本兼容问题\n\n向下兼容问题对于每个软件来说都是一个非常棘手的问题。一方面我们需要让我们的软件持续的发展，另一方面需要兼容之前的代码。现在Dubbo上如果需要对接口进行新加或者变更的时候就会发现需要重新发布Dubbo API的Jar包。这样对于Provider和Consumer都是工作负担。使用版本号控制Dubbo API版本号时就得进行多服务实例启动。这个问题在Dubbo中没有很好的解决。兼容性\n负载均衡就剩下一种方案：客户端负载均衡。\n对于负载均衡来说Dubbo直接使用了客户端负载均衡的策略完成，直接摒弃了服务端负载均衡的可能行。这种情况下对于负载均衡的动态控制与动态管理工作就会形成问题。\n\n- 发布过程支撑问题\n\n线上发布一般基于新旧并存平滑过度的方式进行灰度发布，而对于长链接的Dubbo。不能很好的支撑蓝绿发布，灰度发布方式。\n\n- 运维能力\n\n1. 故障隔离能力：\n\n就现阶段技术而言，没有中很好的方式进行可以进行接口（http和rpc）的故障降级与隔离方式。导致服务中一个接口（http和rpc）发生故障后可能传播到整个服务甚至整个系统中。\n2. 服务隔离能力：\n\n对于整个系统来说部分业务在docker外，部分服务在docker内时就很难进行处理。一套体系最好在一个注册中心中进行服务组册与发现工作。做服务隔离就非常困难。多注册中心\n\n3. 指标监控能力：\n\n指标监控对于线上业务服务来说是不可或缺的内容。但是对于Dubbo来说支持的比较弱。只有几个点完成这个，所以有些鸡肋的感觉。\n4. 服务检测能力：\n\n每个线上服务都需要不断的检测服务的状态，接口响应情况等。对于使用dubbo或heissian方法的检测几乎不太可能。\n\n# 6.版本管理\n## 6.1尽可能推迟\n## 6.2及早发现破坏性修改\n尽量对修改的影响进行全面的回归。\n## 6.3使用语义话的版本管理\n## 6.4不同的接口并存\n当不得不这么做时，我们的生产环境可以同时存在接口的新老版本。\n\n假如一个接口存在着V1、V2、V3三种版本，我们可以在所有对V1的请求转换给V2，然后V2转换给V3，这样是一种平滑的过度，首先扩张服务的能力，对新老两种都支持，然后等老的消费者都采用了新的方式，再通过收缩API去掉旧的功能。\n\n我们也可以在URI中存放版本信息，但同时我们需要一套方法来对不同的请求进行路由。\n## 6.5.同时使用多个版本的服务\n短期内同时使用两个版本的服务是合理的，尤其是当你做蓝绿部署或者金丝雀发布时，在这些情况下，不同版本的服务可能只会存在几分钟或者几个小时，而且一般只会有两个版本。升级\n# 7.用户界面\n\n# 8.与第三方软件的集成","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第3章 如何建模服务","url":"/2021/04/24/微服务设计3/","content":"在本章中，我们会讨论如何确定服务之间的边界，以期最大化微服务的好处，避开它的劣势。\n<!--more-->\n# 1.什么样的服务是好服务\n专注在两个重要的概念上：松耦合和高内聚。\n\n这两个概念在不同的上下文中被大量使用，尤其是在面向对象编程中，所以，我们先讨论一下这两个概念在微服务中是什么含义。\n## 1.1松耦合\n如果做到了服务之间的松耦合，那么修改一个服务就不需要修改另一个服务。使用微服务最重要的一点是，能够独立修改及部署单个服务而不需要修改系统的其他部分，这真的非常重要。\n\n什么会导致紧耦合呢？一个典型的错误是，使用紧耦合的方式做服务之间的集成，从而使得一个服务的修改会致使其消费者的修改。\n\n一个松耦合的服务应该尽可能少地知道与之协作的那些服务的信息。这也意味着，应该限制两个服务之间不同调用形式的数量，因为除了潜在的性能问题之外，过度的通信可能会导致紧耦合。\n\n## 1.2高内聚\n我们希望把相关的行为聚集在一起，把不相关的行为放在别处。为什么呢？因为如果你要改变某个行为的话，最好能够只在一个地方进行修改，然后就可以尽快地发布。如果需要在很多不同的地方做这些修改，那么可能就需要同时发布多个微服务才能交付这个功能。在多个不同的地方进行修改会很慢，同时部署多个服务风险也很高，这两者都是我们想要避免的。\n\n所以，找到问题域的边界就可以确保相关的行为能放在同一个地方，并且它们会和其他边界以尽量松耦合的形式进行通信。\n# 2.限界上下文\nEric Evans 的《领域驱动设计》一书主要专注如何对现实世界的领域进行建模。该书中有很多非常棒的想法，比如通用语言、仓储、抽象等。其中 Evans 引入的一个很重要的概念是限界上下文（bounded context），刚听到这个概念的时候，我深受启发。他认为任何一个给定的领域都包含多个限界上下文，每个限界上下文中的东西（Eric 更常使用模型这个词，应该比“东西”好得多）分成两部分，一部分不需要与外部通信，另一部分则需要。每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他的上下文。\n\n另一个我比较喜欢的限界上下文的定义是：“一个由显式边界限定的特定职责。”（http://blog.sapiensworks.com/post/2012/04/17/DDD-The-Bounded-Context-Explained.aspx）如果你想要从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。在这本书中，Evans 使用细胞作为比喻：“细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。”\n\n## 2.1共享的隐藏模型\n\n财务部门和仓库就可以是两个独立的限界上下文。它们都有明确的对外接口（在存货报告、工资单等方面），也都有着只需要自己知道的一些细节（铲车、计算器）。\n\n![WechatIMG191.jpeg](https://i.loli.net/2021/04/24/qOTdXjpPcg7658n.jpg)\n\n有时候，同一个名字在不同的上下文中有着完全不同的含义。比如，退货表示的是客户退回的一些东西。在客户的上下文中，退货意味着打印运送标签、寄送包裹，然后等待退款。在仓库的上下文中，退货表示的是一个即将到来的包裹，而且这个包裹会重新入库。退货这个概念会与将要执行的任务相关，比如我们可能会发起一个重新入库的请求。这个退货的共享模型会在多个不同的进程中使用，并且在每个限界上下文中都会存在相应的实体，不过，这些实体仅仅是在每个上下文的内部表示而已。\n## 2.2模块和服务\n明白应该共享特定的模型，而不应该共享内部表示这个道理之后，就可以避免潜在的紧耦合（即我们不希望成为的样子）风险。我们还识别出了领域内的一些边界，边界内部是相关性比较高的业务功能，从而得到高内聚。这些限界上下文可以很好地形成组合边界。\n\n就像在第 1 章中讨论过的，在同一个进程内使用模块来减少彼此之间的耦合也是一种选择。刚开始开发一个代码库的时候，这可能是比较好的办法。所以一旦你发现了领域内部的限界上下文，一定要使用模块对其进行建模，同时使用共享和隐藏模型。\n\n所以，如果服务边界和领域的限界上下文能保持一致，并且微服务可以很好地表示这些限界上下文的话，那么恭喜你，你跨出了走向高内聚低耦合的微服务架构的第一步。\n\n## 2.3过早划分\n过早地划分带来的问题：例如一个服务没有划分好，后期导致了很多跨服务的修改，而这些修改的代价相当高。团队逐渐又把这些服务合并成了一个单块系统，从而给所有人时间去理解服务边界到底应该在哪。一年之后，团队识别出了出非常稳定的边界，并据此将这个单块系统拆分成多个微服务。当然这并不是我见过的唯一一个过早划分的例子。过早将一个系统划分成为微服务的代价非常高，尤其是在面对新领域时。很多时候，将一个已有的代码库划分成微服务，要比从头开始构建微服务简单得多。\n# 3.业务功能\n当你在思考组织内的限界上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。比如，仓库的一个功能是提供当前的库存清单，财务上下文能够提供月末账目或者为一个新招的员工创建工资单。为了实现这些功能，可能需要交换存储信息的模型，但是我见过太多只考虑模型从而导致贫血的、基于 CRUD（create，read， update，delete）的服务。所以首先要问自己“这个上下文是做什么用的”，然后再考虑“它需要什么样的数据”。\n\n建模服务时，应该将这些功能作为关键操作提供给其协作者（其他服务）。\n\n# 4.逐步划分上下文\n一开始你会识别出一些粗粒度的限界上下文，而这些限界上下文可能又包含一些嵌套的限界上下文。举个例子，你可以把仓库分解成为不同的部分：订单处理、库存管理、货物接受等。当考虑微服务的边界时，首先考虑比较大的、粗粒度的那些上下文，然后当发现合适的缝隙后，再进一步划分出那些嵌套的上下文。\n# 5.关于业务概念的沟通\n修改系统的目的是为了满足业务需求。我们会修改面向客户的功能。如果把系统分解成为限界上下文来表示领域的话，那么对于某个功能所要做的修改，就更倾向于局限在一个单独的微服务边界之内。这样就减小了修改的范围，并能够更快地进行部署。\n\n微服务之间如何就同一个业务概念进行通信，也是一件很重要的事情。基于业务领域的软件建模不应该止于限界上下文的概念。在组织内部共享的那些相同的术语和想法，也应该被反映到服务的接口上。以跟组织内通信相同的方式，来思考微服务之间的通信形式是非常有用的。事实上，通信形式在整个组织范围内都非常重要。\n\n# 6.技术边界\n按照技术边界对服务边界进行建模会形成洋葱架构，因为它有很多层。但是也并不总是错误的。比如，当一个组织想要达到某个性能目标时，这种划分方式反而更合理。然而一般来讲，这不应该成为你考虑的首要方式。\n\n# 7.总结\n在本章中，你学到了什么是好的服务，以及如何在问题空间中寻找能达到高内聚低耦合的接缝。限界上下文是寻找这些接缝的一个非常重要的工具，通过将微服务与这些边界相匹配，可以保证最终的系统能够得到微服务提供的所有好处。\n\n本章讨论的内容比较宽泛，下一章的内容技术性会更强。在实现服务间接口方面存在很多的陷阱，从而会引入各种各样的麻烦。如果不想系统乱成一团麻，就必须深入讨论一下该话题。\n\n\n","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第2章 演化式架构师","url":"/2021/04/24/微服务设计2/","content":"# 1.不准确的比较\n你总提及的那个词，它的含义与你想表达的意思并不一样。\n<!--more-->\n“建筑师”和“架构师”在英文中都是 architect，而“架构师”这个词的含义借鉴的是建筑师在建筑中的角色。\n\n# 2.架构师的演化视角\n与建造建筑物相比，在软件中我们会面临大量的需求变更，使用的工具和技术也具有多样性。我们创造的东西并不是在某个时间点之后就不再变化了，甚至在发布到生产环境之后，软件还能继续演化。因此架构师必须改变那种从一开始就要设计出完美产品的想法，相反我们应该设计出一个合理框架。\n\n其实，有一个角色可以更好地跟 IT 架构师相类比。那就是城市规划师，而不是建筑师。如果你玩过 SimCity，那么你应该很熟悉城市规划师这个角色。城市规划师的职责是优化城镇布局，使其更易于现有居民生活，同时也会考虑一些未来的因素。为了达到这个目的，他需要收集各种各样的信息。规划师影响城市演化的方法很有趣，他不会直接说“在那个地方盖一栋这样的楼”，相反他会对城市进行分区。就像在 SimCity 中一样，你可能会把城市的某一部分规划成为工业区，另外一部分规划成为居民区，然后其他人会自己决定具体要盖什么建筑物。当然这个决定会受到一定的约束，比如工厂一定要盖在工业区。城市规划师更多考虑的是人和公共设施如何从一个区域移到另一个区域，而不是具体在每个区域中发生的事情。\n\n城市规划师就像建筑师一样，需要知道什么时候他的计划没有得到执行。尽管他会引入较少的规范，并尽量少地对发展的方向进行纠正，但是如果有人决定要在住宅区建造一个污水池，他应该能制止。\n\n所以我们的架构师应该像城市规划师那样专注在大方向上，只在很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前的需求，还能够应对将来的变化。而且他们还应该保证在这个系统上工作的开发人员要和使用这个系统的用户一样开心。听起来这是很高的标准，那么从哪里开始呢？\n# 3.分区\n前面我们将架构师比作城市规划师，那么在这个比喻里面，区域的概念对应的是什么呢？它们应该是我们的服务边界，或者是一些粗粒度的服务群组。作为架构师，不应该过多关注每个区域内发生的事情，而应该多关注区域之间的事情。这意味着我们应该考虑不同的服务之间如何交互，或者说保证我们能够对整个系统的健康状态进行监控。至于多大程度地介入区域内部事务，在不同的情况下则有所不同。很多组织采用微服务是为了使团队的自治性最大化，如果你就处在这样的组织中，那么你会更多地依靠团队来做出正确的局部决定。\n\n\n```\n代码架构师\n\n如果想确保我们创造的系统对开发人员足够友好，那么架构师需要理解他们的决定对系统会造成怎样的影响。\n最低的要求是：架构师需要花时间和团队在一起工作，理想情况下他们应该一起进行编码。\n对于实施结对编程的团队来说，架构师很容易花一定的时间和团队成员进行结对。\n理想情况下，你应该参与普通的工作，这样才能真正理解普通的工作是什么样子。\n架构师和团队真正坐在一起，这件事情再怎么强调也不过分！相比通过电话进行沟通或者只看看团队的代码，一起和团队工作的这种方式会更加有效。\n至于和团队在一起工作的频率可以取决于团队的大小，关键是它必须成为日常工作的一部分。\n如果你和四个团队在一起工作，那么每四周和每个团队都工作半天，可以帮助你有效地和团队进行沟通，并了解他们都在做什么。\n```\n# 4.一个原则性的方法\n\n==**规则对于智者来说是指导，对于愚蠢者来说是遵从。**==\n\n做系统设计方面的决定通常都是在做取舍，而在微服务架构中，你要做很多取舍！当选择一个数据存储技术时，你会选择不太熟悉但能够带来更好可伸缩性的技术吗？在系统中存在两种技术栈是否可接受？那三种呢？做某些决策所需要的信息很容易获取，这些还算是容易的。但是有些决策所需要的信息难以完全获取，那又该怎么办呢？\n\n基于要达到的目标去定义一些原则和实践对做设计来说非常有好处。接下来让我们对它们做一些讨论。\n## 4.1战略目标\n做一名架构师已经很困难了，但幸运的是，通常我们不需要定义战略目标！战略目标关心的是公司的走向以及如何才能让自己的客户满意。这些战略目标的层次一般都很高，但通常不会涉及技术这个层面，一般只在公司或者部门层面制定。\n## 4.2原则\n为了和更大的目标保持一致，我们会制定一些具体的规则，并称之为原则，它不是一成不变的。举个例子，如果组织的一个战略目标是缩短新功能上线的周期，那么一个可能的原则是，交付团队应该对整个软件生命周期有完全的控制权，这样他们就可以及时交付任何就绪的功能，而不受其他团队的限制。如果组织的另一个目标是在其他国家快速增长业务，你需要使用的原则可能就是，整个系统必须能够方便地部署到相应的国家，从而符合该国家对数据存储地理位置方面的要求。\n## 4.3实践\n我们通过相应的实践来保证原则能够得到实施，这些实践能够指导我们如何完成任务。通常这些实践是技术相关的，而且是比较底层的，所以任何一个开发人员都能够理解。这些实践包括代码规范、日志数据集中捕获或者 HTTP/REST 作为标准集成风格等。由于实践比较偏技术层面，所以其改变的频率会高于原则。\n\n就像原则那样，有时候实践也会反映出组织内的一些限制。比如，如果你只支持 CentOS，那么相应的实践就应该考虑这个因素。\n\n实践应该巩固原则。比如前面我们提过一个原则是开发团队应该可以对软件开发全流程有控制权，相应的实践就是所有的服务都部署在不同的 AWS 账户中，从而可以提供资源的自助管理和与其他团队的隔离。\n\n## 4.4将原则和实践结合\n有些东西对一些人来说是原则，对另一些人来说则可能是实践。比如，你可能会把使用 HTTP/REST 作为原则，而不是实践。这也没什么问题，关键是要有一些重要的原则来指导系统的演化，同时也要有一些细节来指导如何实现这些原则。对于一个足够小的群组，比如单个团队来说，将原则和实践进行结合是没问题的。但是在一个大型组织中，技术和工作实践可能不一样，在不同的地方需要的实践可能也不同。不过这也没关系，只要它们都能够映射到相同的原则即可。比如一个 .NET 团队可能有一套实践，一个 Java 团队有另一套实践，但背后的原则是相同的。\n# 5.要求的标准\n在优化单个服务自治性的同时，也要兼顾全局。一种能帮助我们实现平衡的方法就是，清楚地定义出一个好服务应有的属性。\n\n## 5.1监控\n能够清晰地描绘出跨服务系统的健康状态非常关键。这必须在系统级别而非单个服务级别进行考虑。简单起见，我建议确保所有的服务使用同样的方式报告健康状态及其与监控相关的数据。\n\n你可能会选择使用推送机制，也就是说，每个服务主动把数据推送到某个集中的位置。你可以使用 Graphite 来收集指标数据，使用 Nagios 来检测健康状态，或者使用轮询系统来从各个节点收集数据，但无论你的选择是什么，都应尽量保持标准化。每个服务内的技术应该对外不透明，并且不要为了服务的具体实现而改变监控系统。日志功能和监控情况类似：也需要集中式管理。\n## 5.2接口\n选用少数几种明确的接口技术有助于新消费者的集成。使用一种标准方式很好，两种也不太坏，但是 20 种不同的集成技术就太糟糕了。这里说的不仅仅是关于接口的技术和协议。举个例子，如果你选用了 HTTP/REST，在 URL 中你会使用动词还是名词？你会如何处理资源的分页？你会如何处理不同版本的 API ？\n## 5.3架构安全性\n一个运行异常的服务可能会毁了整个系统，而这种后果是我们无法承担的，所以，必须保证每个服务都可以应对下游服务的错误请求。没有很好处理下游错误请求的服务越多，我们的系统就会越脆弱。你可以至少让每个下游服务使用它们自己的连接池，进一步让每个服务使用一个断路器。\n\n# 6.代码治理\n聚在一起，就如何做事情达成共识是一个好主意。但是，花时间保证人们按照这个共识来做事情就没那么有趣了，因为在各个服务中使用这些标准做法会成为开发人员的负担。我坚信应该使用简单的方式把事情做对。我见过的比较奏效的两种方式是，提供范例和服务代码模板。\n## 6.1范例\n编写文档是有用的。我很清楚这样做的价值，这也正是我写这本书的原因。但是开发人员更喜欢可以查看和运行的代码。如果你有一些很好的实践希望别人采纳，那么给出一系列的代码范例会很有帮助。这样做的一个初衷是：如果在系统中人们有比较好的代码范例可以模仿，那么他们也就不会错得很离谱。\n\n理想情况下，你提供的优秀范例应该来自真实项目，而不是专门实现的一个完美的例子。因为如果你的范例来自真正运行的代码，那么就可以保证其中所体现的那些原则都是合理的。\n\n## 6.2裁剪服务代码模板\n如果能够让所有的开发人员很容易地遵守大部分的指导原则，那就太棒了。一种可能的方式是，当开发人员想要实现一个新服务时，所有实现核心属性的那些代码都应该是现成的。\n\n有一点需要注意的是，创建服务代码模板不是某个中心化工具的职责，也不是指导（即使是通过代码）我们应怎样工作的架构团队的职责。应该通过合作的方式定义出这些实践，所以你的团队也需要负责更新这个模板（内部开源的方式能够很好地完成这项工作）。\n\n如果你强制团队使用它，一定要确保它能够简化开发人员的工作，而不是使其复杂化。你还需要知道，重用代码可能引入的危险。在重用代码的驱动下，我们可能会引入服务之间的耦合。\n# 7.技术债务\n有时候可能无法完全遵守技术愿景，比如为了发布一些紧急的特性，你可能会忽略一些约束。其实这仅仅是另一个需要做的取舍而已。我们的技术愿景有其本身的道理，所以偏离了这个愿景短期可能会带来利益，但是长期来看是要付出代价的。可以使用技术债务的概念来帮助我们理解这个取舍，就像在真实世界中欠的债务需要偿还一样，累积的技术债务也是如此。\n\n不光走捷径会引入技术债务。有时候系统的目标会发生改变，并且与现有的实现不符，这种情况也会产生技术债务。\n\n架构师的职责就是从更高的层次出发，理解如何做权衡。理解债务的层次及其对系统的影响非常重要。对于某些组织来说，架构师应该能够提供一些温和的指导，然后让团队自行决定如何偿还这些技术债务。而其他的组织就需要更加结构化的方式，比如维护一个债务列表，并且定期回顾。\n# 8.例外管理\n原则和实践可以指导我们如何构建系统。那么，如果系统偏离了这些指导又会发生什么呢？有时候我们会决定针对某个规则破一次例，然后把它记录下来。\n\n现实中的情况是多种多样的，如果你所在的组织对开发人员有非常多的限制，那么微服务可能并不适合你。\n# 9.集中治理和领导\n架构师的部分职责是治理。那么治理又是什么意思呢？\n\n**治理通过评估干系人的需求、当前情况及下一步的可能性来确保企业目标的达成，通过排优先级和做决策来设定方向。对于已经达成一致的方向和目标进行监督。**\n\n在 IT 的上下文中有很多事情需要治理，而架构师会承担技术治理这部分的职责。如果说，架构师的一个职责是确保有一个技术愿景，那么治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。\n\n架构师会对很多事情负责。他们需要确保有一组可以指导开发的原则，并且这些原则要与组织的战略相符。他们还需要确保，以这些原则为指导衍生出来的实践不会给开发人员带来痛苦。他们需要了解新技术，需要知道在什么时候做怎样的取舍。上述这些职责已经相当多了，但是他们还需要让同事也理解这些决定和取舍，并执行下去。对了，还有前面提到的：他们还需要花时间和团队一起工作，甚至是编码，从而了解所做的决定对团队造成了怎样的影响。\n\n需要在一定程度上相信你的团队。你没法替代他们去骑车。你会看着他们摇摇晃晃地前行，但是，如果每次你看到他们要跌倒就上去扶一把，他们永远都学不会。而且无论如何，他们真正跌倒的次数会比你想象的要少！但是，如果他们马上就要驶入车流繁忙的大马路，或者附近的鸭子池塘，你就必须站出来了。类似地，作为一名架构师，你必须要在团队驶向类似鸭子池塘这样的地方时抓紧他们。还有一点要注意的是，即使你很清楚什么是对的，然后尝试去控制团队，也可能会破坏和团队的关系，并且会使团队感觉他们没有话语权。有时候按照一个你不同意的决定走下去反而是正确的，知道什么时候可以这么做，什么时候不要这么做是很困难的，但有时也很关键。\n\n# 10.建设团队\n对于一个系统技术愿景的主要负责人来说，执行愿景不仅仅等同于做技术决定，和你一起工作的那些人自然会做这些决定。对于技术领导人来说，更重要的事情是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。\n\n伟大的软件来自于伟大的人。所以如果你只担心技术问题，那么恐怕你看到的问题远远不及一半。\n\n# 总结\n\n总结一下，一个演进式架构师应该承担的职责。\n\n- 愿景\n\n确保在系统级有一个经过充分沟通的技术愿景，这个愿景应该可以帮助你满足客户和组织的需求。\n\n- 同理心\n\n理解你所做的决定对客户和同事带来的影响。\n\n- 合作\n\n和尽量多的同事进行沟通，从而更好地对愿景进行定义、修订及执行。\n\n- 适应性\n\n确保在你的客户和组织需要的时候调整技术愿景。\n\n- 自治性\n\n在标准化和团队自治之间寻找一个正确的平衡点。\n\n- 治理\n\n确保系统按照技术愿景的要求实现。\n\n演进式架构师应该理解，成功要靠不断地取舍来实现。总会存在一些原因需要你改变工作的方式，但是具体做哪些改变就只能依赖于自己的经验了。而僵化地固守自己的想法无疑是最糟糕的做法。","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"怎么做到服务的优雅上下线","url":"/2021/04/19/怎么做到服务的优雅上下线/","content":"在平常工作中，服务如果重启，怎么保证一个请求不会被中断处理的呢？\n也就是如何做到让服务优雅的上下线。\n<!--more-->\n# 什么是优雅上下线\n关于\"优雅上下线\"这个词，我没找到官方的解释，我尝试解释一下这是什么。\n首先，上线、下线大家一定都很清楚，比如我们一次应用发布过程中，就需要先将应用服务停掉，然后再把服务启动起来。这个过程就包含了一次下线和一次上线。\n那么，\"优雅\"怎么理解呢？\n先说什么情况我们认为不优雅：\n\n1、服务停止时，没有关闭对应的监控，导致应用停止后发生大量报警。\n\n2、应用停止时，没有通知外部调用方，很多请求还会过来，导致很多调用失败。\n\n3、应用停止时，有线程正在执行中，执行了一半，JVM进程就被干掉了。\n\n4、应用启动时，服务还没准备好，就开始对外提供服务，导致很多失败调用。\n\n5、应用启动时，没有检查应用的健康状态，就开始对外提供服务，导致很多失败调用。\n\n以上，都是我们认为的不优雅的情况，那么，反过来，优雅上下线就是一种避免上述情况发生的手段。\n一个应用的优雅上下线涉及到的内容其实有很多，从底层的操作系统、容器层面，到编程语言、框架层面，再到应用架构层面，涉及到的知识很广泛。\n\n其实，优雅上下线中，最重要的还是优雅下线。因为如果下线过程不优雅的话，就会发生很多调用失败了、服务找不到等问题。所以很多时候，大家也会提优雅停机这样的概念。\n\n本文后面介绍的优雅上下线也重点关注优雅停机的过程。\n# 操作系统&容器的优雅上下线\n我们知道，kill -9之所以不建议使用，是因为kill -9特别强硬，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。\n\n这个过程显然是不优雅的，因为应用立刻停止的话，就没办法做收尾动作。而更优雅的方式是kill -15。\n\n当使用kill -15时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。\n\nkill -15会通知到应用程序，这就是操作系统对于优雅上下线的最基本的支持。\n\n以前，在操作系统之上就是应用程序了，但是，自从容器化技术推出之后，在操作系统和应用程序之间，多了一个容器层，而Docker、k8s等容器其实也是支持优雅上下线的。\n\n如Docker中同样提供了两个命令， docker stop 和 docker kill\ndocker stop就像kill -15一样，他会向容器内的进程发送SIGTERM信号，在10S之后（可通过参数指定）再发送SIGKILL信号。\n\n而docker kill就像kill -9，直接发送SIGKILL信号。\n# JVM的优雅上下线\n在操作系统、容器等对优雅上下线有了基本的支持之后，在接收到docker stop、kill -15等命令后，会通知应用进程进行进程关闭。\n\n而Java应用在运行时就是一个独立运行的进程，这个进程是如何关闭的呢？\n\nJava程序的终止运行是基于JVM的关闭实现的，JVM关闭方式分为正常关闭、强制关闭和异常关闭3种。\n\n这其中，正常关闭就是支持优雅上下线的。正常关闭过程中，JVM可以做一些清理动作，比如删除临时文件。\n\n当然，开发者也是可以自定义做一些额外的事情的，比如通知应用框架优雅上下线操作。\n\n而这种机制是通过JDK中提供的shutdown hook实现的。JDK提供了Java.Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的钩子。\n\n例子如下：\n\n```\npackage com.test;\n\n    public class ShutdownHookTest {\n\n        public static void main(String[] args) {\n\n            boolean flag = true;\n\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n\n                System.out.println(\"hook execute...\");\n\n            }));\n\n            while (flag) {\n\n                // app is runing\n\n            }\n\n            System.out.println(\"main thread execute end...\");\n\n        }\n\n    }\n\n```\n执行命令：\n\n```\njps\n 6520 ShutdownHookTest\n 6521 Jps\nkill 6520\n```\n控制台输出内容：\n\n```\n hook execute...\n\n Process finished with exit code 143 (interrupted by signal 15: SIGTERM)\n```\n可以看到，当我们使用kill（默认kill -15）关闭进程的时候，程序会先执行我注册的shutdownHook，然后再退出，并且会给出一个提示：interrupted by signal 15: SIGTERM\n# Spring的优雅上下线\n有了JVM提供的shutdown hook之后，很多框架都可以通过这个机制来做优雅下线的支持。\n比如Spring，他就会向JVM注册一个shutdown hook，在接收到关闭通知的时候，进行bean的销毁，容器的销毁处理等操作。\n同时，作为一个成熟的框架，Spring也提供了事件机制，可以借助这个机制实现更多的优雅上下线功能。\nApplicationListener是Spring事件机制的一部分，与抽象类ApplicationEvent类配合来完成ApplicationContext的事件机制。\n开发者可以实现ApplicationListener接口，监听到 Spring 容器的关闭事件（ContextClosedEvent），来做一些特殊的处理：\n\n```\n@Component\n\n    public class MyListener implements ApplicationListener<ContextClosedEvent> {\n\n        @Override\n\n        public void onApplicationEvent(ContextClosedEvent event) {\n\n            // 做容器关闭之前的清理工作\n\n        }\n\n    }\n```\n# Dubbo的优雅上下线\n因为Spring中提供了ApplicationListener接口，帮助我们来监听容器关闭事件，那么，很多web容器、框架等就可以借助这个机制来做自己的优雅上下线操作。\n如tomcat、dubbo等都是这么做的。\n这里简答说一下Dubbo的，在Dubbo的官网中，有关于优雅停机的介绍：\n![WechatIMG188.jpeg](https://i.loli.net/2021/04/19/5nRCTzufWOiSKYU.jpg)\n应用在停机时，接收到关闭通知时，会先把自己标记为不接受（发起）新请求，然后再等待10s（默认是10秒）的时候，等执行中的线程执行完。\n\n那么，之所以他能做这些事，是因为从操作系统、到JVM、到Spring等都对优雅停机做了很好的支持。\n\n目前，Dubbo中实现方式如下，同样是用到了Spring的事件机制：\n\n```\npublic class SpringExtensionFactory implements ExtensionFactory {\n\n        public static void addApplicationContext(ApplicationContext context) {\n\n            CONTEXTS.add(context);\n\n            if (context instanceof ConfigurableApplicationContext) {\n\n                ((ConfigurableApplicationContext) context).registerShutdownHook();\n\n                DubboShutdownHook.getDubboShutdownHook().unregister();\n\n            }\n\n            BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);\n\n        }\n\n    }\n```\n# 总结\n本文从操作系统开始，分别介绍了Linux、Docker、JVM、Spring、Dubbo等对优雅停机的支持。\n可以看到，一个简单的优雅停机功能，上下游需要这么多底层基础设施和上层应用的支持。\n相信通过学习本文，你一定对优雅上下线有了更多的了解。\n除此之外，我还希望你，通过本文以后，遇到一些实际问题的时候，可以想到文中提到的shutdown hook机制、Spring的event机制。很多时候，这些机制都能帮助我们解决很多问题。\n\n参考：\n\nhttps://mp.weixin.qq.com/s/qBKaRt34zeSI0OzBEAnu7g\n\nhttps://zhuanlan.zhihu.com/p/29093407\n\nhttps://www.cnkirito.moe/dubbo-gracefully-shutdown/\n\nhttps://www.cnkirito.moe/dubbo-gracefully-shutdown/\n","tags":["部署","技能包"],"categories":["技能包"]},{"title":"《微服务设计》第1章 微服务","url":"/2021/04/18/微服务设计1/","content":"最近在重读《微服务设计》这本书，我会输出我认为的精华部分所在，希望自己能有更多的总结领悟和思想碰撞，从而提升自己。重新审视微服务该如何设计。开始吧：\n<!--more-->\n# 1.什么是微服务\n微服务就是一些协同工作的小而自治的服务。\n## 1.1 很小，专注于做好一件事\n随着新功能的增加，代码库会越变越大。时间久了代码库会越来越庞大，以至于想要知道应该在什么地方做修改都很困难。尽管我们想在巨大的代码库中做到清晰地模块化，但事实上这些模块之间的界限很难维护。相似的功能代码开始在代码库中随处可见，这让修复bug和修改原有实现更加困难。\n微服务将内聚性这个理念应用在独立的服务上。根据业务的边界来确定服务的边界，这样就很容易确定某个功能代码应该放在哪里。由于该服务专注于某个边界之内，因此可以很好地避免由于代码库过大而衍生出来的很多让人头痛的问题。\n那么代码库多小才算小？作者给出的一个比较老套的方案是：足够小即可，不要过小。那么换句话说，如果你不再感觉你的代码库过大，可能他就足够小了。还有一点就是该服务是否能够很好的与团队结构相匹配。\n服务越小，微服务架构的优点和缺点也就越明显。使用的服务越小，独立性带来的好处就越多。但是管理大量服务带来的复杂性也会越来越大。\n如果你能够很好的处理这一复杂性，那就可以尽情地使用较小的服务了。\n## 1.2 自治性\n一个微服务就是一个独立的实体。它可以独立地部署在PAAS上，也可以作为一个操作系统的进程存在。我们要尽量避免把多个服务部署在同一台机器上，尽管这种隔离性会带来一些代价。\n服务直接均通过网络调用进行通信，从而加强了服务直接的隔离性，避免紧耦合。\n这些服务应该可以彼此间独立进行修改，对于一个服务来说，我们应该考虑暴露应该暴露的部分，如果暴露过多服务消费方和提供方就会产生耦合。这回使得服务提供方和消费方直接产生额外的协调工作，从而降低服务的自治性。\n服务提供者会暴露出API，然后服务之间通过这些API进行通信。如果系统没有很好地进行解耦，那么一旦出现问题，所有的功能都将不可用。\n# 2.微服务的主要好处\n## 2.1 技术异构性\n在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。尝试使用一种适合所有场景的标准化技术，会使得所有的场景都无法得到很好的支持。\n微服务可以帮助我们轻松地采用不同的技术：\n![WechatIMG186.png](https://i.loli.net/2021/04/18/LDNp6jw9mdAUuGB.png)\n## 2.2 弹性\n弹性工程学的一个关键概念是舱壁虎。其实服务边界就是一个很显然的舱壁。微服务可以改进弹性，但你还是需要谨慎对待，因为一旦使用了分布式系统，网络就是个问题，机器也是个问题。因此我们需要了解出现问题时应该如何对用户进行友好展示。\n## 2.3 扩展\n庞大的单体服务只能作为一个整体进行扩展。即使系统中只有一部分存在性能问题，也需要对整个服务进行扩展。如果使用较小的服务，则可以选择只对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在性能更差的硬件上从而节省成本。\n![WechatIMG10455.png](https://i.loli.net/2021/04/18/29HVyxR1jODXJpM.png)\n## 2.4 简化部署\n在几百万代码行的单体应用程序中，即使你只修改了一行代码，也要重新部署整个服务发布该变更。\n在微服务架构中，各个服务的部署是独立的，这样就能更快的对特定部分的代码进行部署。如果真的出了问题，也只会影响一个服务，并且容易快速回滚。\n## 2.5 与组织架构相匹配\n微服务架构可以将架构和组织结构相匹配，避免出现过大的代码库，从而获得理想的团队大小和生产力。服务的所有权也可以在团队直接迁移，从而避免异地团队的出现。\n## 2.6 可组合性\n在微服务架构中，系统会开放很多接口供外部使用。而单体应用只能提供一个非常粗粒度的接口供外部使用。所以微服务架构可以达到可重用，可组合的目的。\n## 对可代替性的优化\n想想看，在一个庞大的单体应用中你敢不敢在一天内删掉上百行代码，并且确性不会引发问题。所以使用微服务架构的团队可以在需要时轻易地重写服务，或者删除不再使用的服务。\n# 3.面向服务的架构\nSOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列的功能。SOA本身是一个很好的想法，但尽管做了很多尝试，人们还是无法在如何做好SOA这件事情上达成共识。因为业界大部分的尝试都没能把它当作一个整体来看待，因此很难给出一个比该领域现有厂家提供的方案更好呢替代方案，也就是没有对应的标准和方法论。所以在实施SOA时会遇到一些问题：通信协议如何选择、第三方中间件如何选择、服务粒度如何确定等。而这事实上就是微服务架构，你也可以认为微服务架构是SOA的一种特定方法。\n# 4.没有银弹\n软件工程没有银弹，微服务也是如此，它不是免费的午餐，更不是银弹。选择微服务的同时，你需要在部署、测试、监控等方面做很多的工作，你还需要考虑如何扩展系统，并且保证他们的弹性，还需要处理分布式事务与CAP相关的问题。\n每个公司、组织及系统都不一样。微服务是否适合你，或者说你能够在多大的程度上采用微服务，取决于很多因素。\n\n架构师承担了驱动系统演化的职责，而引入微服务之后的一个主要挑战就是，架构师职责的相应变化。下一章会讲到有哪些方法可以保证我们从这个新架构中受益。\n\n\n","tags":["架构","微服务"],"categories":["架构探险","微服务设计"]},{"title":"安装bamboo，使用postgresql存储数据","url":"/2021/04/16/安装bamboo/","content":"\n# 1、编辑dockerfile 文件\n\n```\nFROM atlassian/bamboo-server:7.2.1\n\nUSER root\n```\n<!--more-->\n# 2、将代理破解包加入容器\n\n```\nCOPY \"atlassian-agent.jar\" /opt/atlassian/bamboo/\nCOPY \"mysql-connector-java-8.0.18.jar\" /opt/atlassian/bamboo/lib/\n```\n\n# 3、设置启动加载代理包\n\n```\nRUN echo 'export CATALINA_OPTS=\"-javaagent:/opt/atlassian/bamboo/atlassian-agent.jar ${CATALINA_OPTS}\"' >> /opt/atlassian/bamboo/bin/setenv.sh\n```\n\n\n# 4、编译dockerfile文件，生成镜像\n\n```\ndocker build -t hl/bamboo:7.2.1\n```\n\n# 5、运行容器\n\n```\ndocker run -d --name hl-bamboo \\\n--restart always \\\n-p 8085:8085 \\\n-p 54663:54663 \\\n-e TZ=\"Asia/Shanghai\" \\\n-v /home/atlassian/bamboo/data:/var/atlassian/application-data/bamboo \\\n-v /home/atlassian/bamboo/settings.xml:/opt/maven/settings.xml \\\nhl/bamboo:7.2.1\n```\n\n\n# 6、破解\n\n```\njava -jar atlassian-agent.jar -d -m bamboo@guwenxiang.com -n bamboo -p bamboo -o http://47.28.176.98 -s xxxx-xxxx-xxxx\n```\n","tags":["linux"],"categories":["服务器","bamboo"]},{"title":"我的概要设计思路","url":"/2021/04/16/我的概要设计思路/","content":"如下：\n<!--more-->\n![我的概要设计思路.png](https://i.loli.net/2021/04/16/1bIT79ZoDFnUeBO.png)","tags":["项目管理","概要设计"],"categories":["项目管理","概要设计"]},{"title":"个人想法","url":"/2021/04/15/开始/","content":"这是一个在线个人笔记，记录我的总结和输出，写下来就不会丢。\n<!--more-->\n\n借用王安石的《游褒禅山记》激励自己吧：夫夷以近，则游者众；险以远，则至者少；而世之奇伟瑰怪非常之观，常在于险远而人之所罕至焉，故非有志者不能至也。\n\n![WechatIMG189.jpeg](https://i.loli.net/2021/04/19/E7eh1kNU4JnWqtx.jpg)\n","tags":["生活"],"categories":["生活"]}]