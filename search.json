[{"title":"《微服务设计》第12章 总结","url":"/2021/04/24/微服务设计12/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第11章 规模化微服务","url":"/2021/04/24/微服务设计11/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第10章 康威定律和系统设计","url":"/2021/04/24/微服务设计10/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第9章 安全","url":"/2021/04/24/微服务设计9/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第8章 监控","url":"/2021/04/24/微服务设计8/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第7章 测试","url":"/2021/04/24/微服务设计7/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第6章 部署","url":"/2021/04/24/微服务设计6/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第5章 分解单块系统","url":"/2021/04/24/微服务设计5/","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第4章 集成","url":"/2021/04/24/微服务设计4/","content":"集成是微服务相关技术中最重要的一个。做的好，可以保持微服务的自治性，做的不好会带来灾难。\n你总提及的那个词，它的含义与你想表达的意思并不一样。\n<!--more-->\n# 1.理想的集成技术\n## 1.1避免破坏性修改\n\n```\n如果在一个微服务的响应中添加一个字段，服务的消费方不应该受到影响。\n```\n\n## 1.2保证API的技术无关性\n\n\n```\n微服务之间的通信应该是与技术无关的。\n```\n\n\n## 1.3使服务的消费方易于使用\n\n\n```\n如果消费方使用该服务比登天还难，那么无论该微服务多漂亮都没用任何意义。但同时，易于使用的服务可能内部封装了很多细节，这会增加耦合。\n```\n\n\n## 1.4隐藏内部实现细节\n\n\n```\n消费方与服务方的内部细节应该是分开的，如果与细节绑定，则意味着改变服务内部的一些变化，消费方也要跟着修改，这会增加修改的成本。\n```\n# 2.数据库共享？\n共享数据库是最快的集成方式，但这种方式应该避免。\n\n如果共享了数据库，那么外部的服务则能查看内部的实现细节，并与其绑定在一起，存储在数据库中的数据结构对所有人来说都是平等的，数据库是一个很大的共享API，那么为了不影响其他服务，必须非常小心地避免修改与其他服务相关的表结构。这样的情况下，需要做大量的回归测试来保证功能的正确性。\n\n其次，消费方与服务方的特定技术绑定在了一起，如果消费方要从关系型数据库换成非关系型数据库，那么这样是不容易实现的。这不符合低耦合的原则。\n\n最后，那么原本由服务方提供的修改，现在可以由各个消费方直接操作数据库来完成，而且每个消费方可能都会有一套自己的修改方法。这不符合高内聚的原则。\n# 3.同步与异步\n如果使用同步方式进行通信，发起方发起一个远程调用后，发起方会阻塞自己并等待整个操作的完成。\n\n异步通信对于运行时间较长的任务来说比较有用，异步的通信模型有两种。\n\n一种是请求/响应方式，这与同步的不同，它是在发起一个请求时，同时注册一个回调，当服务端操作结束之后，会调用该回调。\n\n一种是基于事件的方式，服务提供方不发起请求，而是发布一个事件，然后期待调用方接收消息，并知道该怎么做，服务提供方不需要知道该或者什么会对此做出响应，这也意味着，你可以在不影响服务提供方的情况下对该事件添加新的订阅。\n# 4.编排与协同\n假如你现在一家网站上注册账户，在注册账户系统做了下面三件事：\n\n（1）在客户的积分账户上创建一条记录\n\n（2）通过EMS系统发送一个欢迎礼包\n\n（3）向客户发送欢迎电子邮件\n\n当考虑实现时，编排是一种架构风格，它由一个中心大脑来指导并驱动整个流程。它可由客户管理这个服务来承担，在创建客户时会跟积分账户服务、电子邮件服务及EMS服务通过请求/响应的方式进行通信。客户管理服务可以对当前进行到了哪一步进行跟踪，它会检查积分账户是否创建成功、电子邮件是否发送出去、EMS包裹是否寄出。这种方式的缺点是：客户管理服务承担了太多职责，它会成为网关结构的中心和很多逻辑的起点。这样会导致少量的“上帝”服务，而与其打资产的那些服务通常会沦为贫血的CRUD服务。\n\n另一种实现的风格则是协同，它仅仅告知各个系统各自的职责，具体的实现留给他们自己。就上例而言，客户管理服务创建一个事件，邮件服务、积分服务、EMS服务会订阅这些事件并做相应的处理，如果其他的服务也关心客户创建这件事情，它们只需要简单的订阅该事件即可。这种方式能显著地消除耦合，但这需要额外做一些监控工作，以保证其正确进行。我们可以建一个跟业务流程相匹配的监控服务，分别监控每个服务。\n# 5.远程过程调用\n\nrpc带来的问题，用dubbo举例：\n- 耦合问题\n- \n刚开始使用Dubbo大家都会很容易的接受Provider和Consumer的jar包方式进行服务的管理工作。而慢慢的逐渐深入使用会逐渐的体会到Dubbo的API JAR包变成了一种约束。这样就非常间接，不明显的将Provider和Consumer绑定在一起。如果其中一方出现问题，就会造成另外一方的一些问题。\n\n- 语言锁定\n\n微服务的一个准则就是每个服务可以独立的演进，独立发展。可以通过不同的编程语言对服务进行编写。而Dubbo和类似的RPC实现方式使用Jar包的方式发布接口，那么就只能使用JVM上语言进行Jar的解析与加载工作。导致必须使用相同的语言进行rpc接口的调用。\n\n- 上下文传递\n\nHttp是一种无状态服务，那并不代表RPC必须是一种无状态服务。在Http协议通过不断的发展在协议中传递了一些有状态的上下文信息，这样可以为服务提供一些有状态的信息以便在业务处理过程中使用。而RPC是一种更加纯粹的无状态服务，它没有标准化的规范导致不可能形成完善的解决方案。在Dubbo中可以借助多种方式进行上下文的传递工作，不过实现起来比较复杂。其中包括：Dubbo 上下文信息，事件通知，协议扩展\n\n- 版本兼容问题\n\n向下兼容问题对于每个软件来说都是一个非常棘手的问题。一方面我们需要让我们的软件持续的发展，另一方面需要兼容之前的代码。现在Dubbo上如果需要对接口进行新加或者变更的时候就会发现需要重新发布Dubbo API的Jar包。这样对于Provider和Consumer都是工作负担。使用版本号控制Dubbo API版本号时就得进行多服务实例启动。这个问题在Dubbo中没有很好的解决。兼容性\n负载均衡就剩下一种方案：客户端负载均衡。\n对于负载均衡来说Dubbo直接使用了客户端负载均衡的策略完成，直接摒弃了服务端负载均衡的可能行。这种情况下对于负载均衡的动态控制与动态管理工作就会形成问题。\n\n- 发布过程支撑问题\n\n线上发布一般基于新旧并存平滑过度的方式进行灰度发布，而对于长链接的Dubbo。不能很好的支撑蓝绿发布，灰度发布方式。\n\n- 运维能力\n\n1. 故障隔离能力：\n\n就现阶段技术而言，没有中很好的方式进行可以进行接口（http和rpc）的故障降级与隔离方式。导致服务中一个接口（http和rpc）发生故障后可能传播到整个服务甚至整个系统中。\n2. 服务隔离能力：\n\n对于整个系统来说部分业务在docker外，部分服务在docker内时就很难进行处理。一套体系最好在一个注册中心中进行服务组册与发现工作。做服务隔离就非常困难。多注册中心\n\n3. 指标监控能力：\n\n指标监控对于线上业务服务来说是不可或缺的内容。但是对于Dubbo来说支持的比较弱。只有几个点完成这个，所以有些鸡肋的感觉。\n4. 服务检测能力：\n\n每个线上服务都需要不断的检测服务的状态，接口响应情况等。对于使用dubbo或heissian方法的检测几乎不太可能。\n\n# 6.版本管理\n## 6.1尽可能推迟\n## 6.2及早发现破坏性修改\n尽量对修改的影响进行全面的回归。\n## 6.3使用语义话的版本管理\n## 6.4不同的接口并存\n当不得不这么做时，我们的生产环境可以同时存在接口的新老版本。\n\n假如一个接口存在着V1、V2、V3三种版本，我们可以在所有对V1的请求转换给V2，然后V2转换给V3，这样是一种平滑的过度，首先扩张服务的能力，对新老两种都支持，然后等老的消费者都采用了新的方式，再通过收缩API去掉旧的功能。\n\n我们也可以在URI中存放版本信息，但同时我们需要一套方法来对不同的请求进行路由。\n## 6.5.同时使用多个版本的服务\n短期内同时使用两个版本的服务是合理的，尤其是当你做蓝绿部署或者金丝雀发布时，在这些情况下，不同版本的服务可能只会存在几分钟或者几个小时，而且一般只会有两个版本。升级\n# 7.用户界面\n\n# 8.与第三方软件的集成","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第3章 如何建模服务","url":"/2021/04/24/微服务设计3/","content":"现在你已经知道什么是微服务了，希望你对它的主要优点也有所理解。你可能已经迫不及待地想要实现它了，对吗？但是从何做起呢？在本章中，我们会讨论如何确定服务之间的边界，以期最大化微服务的好处，避开它的劣势。\n<!--more-->\n# 1.什么样的服务是好服务\n专注在两个重要的概念上：松耦合和高内聚。\n\n这两个概念在不同的上下文中被大量使用，尤其是在面向对象编程中，所以，我们先讨论一下这两个概念在微服务中是什么含义。\n## 1.1松耦合\n如果做到了服务之间的松耦合，那么修改一个服务就不需要修改另一个服务。使用微服务最重要的一点是，能够独立修改及部署单个服务而不需要修改系统的其他部分，这真的非常重要。\n\n什么会导致紧耦合呢？一个典型的错误是，使用紧耦合的方式做服务之间的集成，从而使得一个服务的修改会致使其消费者的修改。\n\n一个松耦合的服务应该尽可能少地知道与之协作的那些服务的信息。这也意味着，应该限制两个服务之间不同调用形式的数量，因为除了潜在的性能问题之外，过度的通信可能会导致紧耦合。\n\n## 1.2高内聚\n我们希望把相关的行为聚集在一起，把不相关的行为放在别处。为什么呢？因为如果你要改变某个行为的话，最好能够只在一个地方进行修改，然后就可以尽快地发布。如果需要在很多不同的地方做这些修改，那么可能就需要同时发布多个微服务才能交付这个功能。在多个不同的地方进行修改会很慢，同时部署多个服务风险也很高，这两者都是我们想要避免的。\n\n所以，找到问题域的边界就可以确保相关的行为能放在同一个地方，并且它们会和其他边界以尽量松耦合的形式进行通信。\n# 2.限界上下文\nEric Evans 的《领域驱动设计》一书主要专注如何对现实世界的领域进行建模。该书中有很多非常棒的想法，比如通用语言、仓储、抽象等。其中 Evans 引入的一个很重要的概念是限界上下文（bounded context），刚听到这个概念的时候，我深受启发。他认为任何一个给定的领域都包含多个限界上下文，每个限界上下文中的东西（Eric 更常使用模型这个词，应该比“东西”好得多）分成两部分，一部分不需要与外部通信，另一部分则需要。每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他的上下文。\n\n另一个我比较喜欢的限界上下文的定义是：“一个由显式边界限定的特定职责。”（http://blog.sapiensworks.com/post/2012/04/17/DDD-The-Bounded-Context-Explained.aspx）如果你想要从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。在这本书中，Evans 使用细胞作为比喻：“细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。”\n\n## 2.1共享的隐藏模型\n\n财务部门和仓库就可以是两个独立的限界上下文。它们都有明确的对外接口（在存货报告、工资单等方面），也都有着只需要自己知道的一些细节（铲车、计算器）。\n\n![WechatIMG191.jpeg](https://i.loli.net/2021/04/24/qOTdXjpPcg7658n.jpg)\n\n有时候，同一个名字在不同的上下文中有着完全不同的含义。比如，退货表示的是客户退回的一些东西。在客户的上下文中，退货意味着打印运送标签、寄送包裹，然后等待退款。在仓库的上下文中，退货表示的是一个即将到来的包裹，而且这个包裹会重新入库。退货这个概念会与将要执行的任务相关，比如我们可能会发起一个重新入库的请求。这个退货的共享模型会在多个不同的进程中使用，并且在每个限界上下文中都会存在相应的实体，不过，这些实体仅仅是在每个上下文的内部表示而已。\n## 2.2模块和服务\n明白应该共享特定的模型，而不应该共享内部表示这个道理之后，就可以避免潜在的紧耦合（即我们不希望成为的样子）风险。我们还识别出了领域内的一些边界，边界内部是相关性比较高的业务功能，从而得到高内聚。这些限界上下文可以很好地形成组合边界。\n\n就像在第 1 章中讨论过的，在同一个进程内使用模块来减少彼此之间的耦合也是一种选择。刚开始开发一个代码库的时候，这可能是比较好的办法。所以一旦你发现了领域内部的限界上下文，一定要使用模块对其进行建模，同时使用共享和隐藏模型。\n\n所以，如果服务边界和领域的限界上下文能保持一致，并且微服务可以很好地表示这些限界上下文的话，那么恭喜你，你跨出了走向高内聚低耦合的微服务架构的第一步。\n\n## 2.3过早划分\n过早地划分带来的问题：例如一个服务没有划分好，后期导致了很多跨服务的修改，而这些修改的代价相当高。团队逐渐又把这些服务合并成了一个单块系统，从而给所有人时间去理解服务边界到底应该在哪。一年之后，团队识别出了出非常稳定的边界，并据此将这个单块系统拆分成多个微服务。当然这并不是我见过的唯一一个过早划分的例子。过早将一个系统划分成为微服务的代价非常高，尤其是在面对新领域时。很多时候，将一个已有的代码库划分成微服务，要比从头开始构建微服务简单得多。\n# 3.业务功能\n当你在思考组织内的限界上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。比如，仓库的一个功能是提供当前的库存清单，财务上下文能够提供月末账目或者为一个新招的员工创建工资单。为了实现这些功能，可能需要交换存储信息的模型，但是我见过太多只考虑模型从而导致贫血的、基于 CRUD（create，read， update，delete）的服务。所以首先要问自己“这个上下文是做什么用的”，然后再考虑“它需要什么样的数据”。\n\n建模服务时，应该将这些功能作为关键操作提供给其协作者（其他服务）。\n\n# 4.逐步划分上下文\n一开始你会识别出一些粗粒度的限界上下文，而这些限界上下文可能又包含一些嵌套的限界上下文。举个例子，你可以把仓库分解成为不同的部分：订单处理、库存管理、货物接受等。当考虑微服务的边界时，首先考虑比较大的、粗粒度的那些上下文，然后当发现合适的缝隙后，再进一步划分出那些嵌套的上下文。\n# 5.关于业务概念的沟通\n修改系统的目的是为了满足业务需求。我们会修改面向客户的功能。如果把系统分解成为限界上下文来表示领域的话，那么对于某个功能所要做的修改，就更倾向于局限在一个单独的微服务边界之内。这样就减小了修改的范围，并能够更快地进行部署。\n\n微服务之间如何就同一个业务概念进行通信，也是一件很重要的事情。基于业务领域的软件建模不应该止于限界上下文的概念。在组织内部共享的那些相同的术语和想法，也应该被反映到服务的接口上。以跟组织内通信相同的方式，来思考微服务之间的通信形式是非常有用的。事实上，通信形式在整个组织范围内都非常重要。\n\n# 6.技术边界\n按照技术边界对服务边界进行建模会形成洋葱架构，因为它有很多层。但是也并不总是错误的。比如，当一个组织想要达到某个性能目标时，这种划分方式反而更合理。然而一般来讲，这不应该成为你考虑的首要方式。\n\n# 7.总结\n在本章中，你学到了什么是好的服务，以及如何在问题空间中寻找能达到高内聚低耦合的接缝。限界上下文是寻找这些接缝的一个非常重要的工具，通过将微服务与这些边界相匹配，可以保证最终的系统能够得到微服务提供的所有好处。\n\n本章讨论的内容比较宽泛，下一章的内容技术性会更强。在实现服务间接口方面存在很多的陷阱，从而会引入各种各样的麻烦。如果不想系统乱成一团麻，就必须深入讨论一下该话题。\n\n\n","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"《微服务设计》第2章 演化式架构师","url":"/2021/04/24/微服务设计2/","content":"# 1.不准确的比较\n你总提及的那个词，它的含义与你想表达的意思并不一样。\n<!--more-->\n“建筑师”和“架构师”在英文中都是 architect，而“架构师”这个词的含义借鉴的是建筑师在建筑中的角色。\n\n# 2.架构师的演化视角\n与建造建筑物相比，在软件中我们会面临大量的需求变更，使用的工具和技术也具有多样性。我们创造的东西并不是在某个时间点之后就不再变化了，甚至在发布到生产环境之后，软件还能继续演化。因此架构师必须改变那种从一开始就要设计出完美产品的想法，相反我们应该设计出一个合理框架。\n\n其实，有一个角色可以更好地跟 IT 架构师相类比。那就是城市规划师，而不是建筑师。如果你玩过 SimCity，那么你应该很熟悉城市规划师这个角色。城市规划师的职责是优化城镇布局，使其更易于现有居民生活，同时也会考虑一些未来的因素。为了达到这个目的，他需要收集各种各样的信息。规划师影响城市演化的方法很有趣，他不会直接说“在那个地方盖一栋这样的楼”，相反他会对城市进行分区。就像在 SimCity 中一样，你可能会把城市的某一部分规划成为工业区，另外一部分规划成为居民区，然后其他人会自己决定具体要盖什么建筑物。当然这个决定会受到一定的约束，比如工厂一定要盖在工业区。城市规划师更多考虑的是人和公共设施如何从一个区域移到另一个区域，而不是具体在每个区域中发生的事情。\n\n城市规划师就像建筑师一样，需要知道什么时候他的计划没有得到执行。尽管他会引入较少的规范，并尽量少地对发展的方向进行纠正，但是如果有人决定要在住宅区建造一个污水池，他应该能制止。\n\n所以我们的架构师应该像城市规划师那样专注在大方向上，只在很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前的需求，还能够应对将来的变化。而且他们还应该保证在这个系统上工作的开发人员要和使用这个系统的用户一样开心。听起来这是很高的标准，那么从哪里开始呢？\n# 3.分区\n前面我们将架构师比作城市规划师，那么在这个比喻里面，区域的概念对应的是什么呢？它们应该是我们的服务边界，或者是一些粗粒度的服务群组。作为架构师，不应该过多关注每个区域内发生的事情，而应该多关注区域之间的事情。这意味着我们应该考虑不同的服务之间如何交互，或者说保证我们能够对整个系统的健康状态进行监控。至于多大程度地介入区域内部事务，在不同的情况下则有所不同。很多组织采用微服务是为了使团队的自治性最大化，如果你就处在这样的组织中，那么你会更多地依靠团队来做出正确的局部决定。\n\n\n```\n代码架构师\n\n如果想确保我们创造的系统对开发人员足够友好，那么架构师需要理解他们的决定对系统会造成怎样的影响。\n最低的要求是：架构师需要花时间和团队在一起工作，理想情况下他们应该一起进行编码。\n对于实施结对编程的团队来说，架构师很容易花一定的时间和团队成员进行结对。\n理想情况下，你应该参与普通的工作，这样才能真正理解普通的工作是什么样子。\n架构师和团队真正坐在一起，这件事情再怎么强调也不过分！相比通过电话进行沟通或者只看看团队的代码，一起和团队工作的这种方式会更加有效。\n至于和团队在一起工作的频率可以取决于团队的大小，关键是它必须成为日常工作的一部分。\n如果你和四个团队在一起工作，那么每四周和每个团队都工作半天，可以帮助你有效地和团队进行沟通，并了解他们都在做什么。\n```\n# 4.一个原则性的方法\n\n==**规则对于智者来说是指导，对于愚蠢者来说是遵从。**==\n\n做系统设计方面的决定通常都是在做取舍，而在微服务架构中，你要做很多取舍！当选择一个数据存储技术时，你会选择不太熟悉但能够带来更好可伸缩性的技术吗？在系统中存在两种技术栈是否可接受？那三种呢？做某些决策所需要的信息很容易获取，这些还算是容易的。但是有些决策所需要的信息难以完全获取，那又该怎么办呢？\n\n基于要达到的目标去定义一些原则和实践对做设计来说非常有好处。接下来让我们对它们做一些讨论。\n## 4.1战略目标\n做一名架构师已经很困难了，但幸运的是，通常我们不需要定义战略目标！战略目标关心的是公司的走向以及如何才能让自己的客户满意。这些战略目标的层次一般都很高，但通常不会涉及技术这个层面，一般只在公司或者部门层面制定。\n## 4.2原则\n为了和更大的目标保持一致，我们会制定一些具体的规则，并称之为原则，它不是一成不变的。举个例子，如果组织的一个战略目标是缩短新功能上线的周期，那么一个可能的原则是，交付团队应该对整个软件生命周期有完全的控制权，这样他们就可以及时交付任何就绪的功能，而不受其他团队的限制。如果组织的另一个目标是在其他国家快速增长业务，你需要使用的原则可能就是，整个系统必须能够方便地部署到相应的国家，从而符合该国家对数据存储地理位置方面的要求。\n## 4.3实践\n我们通过相应的实践来保证原则能够得到实施，这些实践能够指导我们如何完成任务。通常这些实践是技术相关的，而且是比较底层的，所以任何一个开发人员都能够理解。这些实践包括代码规范、日志数据集中捕获或者 HTTP/REST 作为标准集成风格等。由于实践比较偏技术层面，所以其改变的频率会高于原则。\n\n就像原则那样，有时候实践也会反映出组织内的一些限制。比如，如果你只支持 CentOS，那么相应的实践就应该考虑这个因素。\n\n实践应该巩固原则。比如前面我们提过一个原则是开发团队应该可以对软件开发全流程有控制权，相应的实践就是所有的服务都部署在不同的 AWS 账户中，从而可以提供资源的自助管理和与其他团队的隔离。\n\n## 4.4将原则和实践结合\n有些东西对一些人来说是原则，对另一些人来说则可能是实践。比如，你可能会把使用 HTTP/REST 作为原则，而不是实践。这也没什么问题，关键是要有一些重要的原则来指导系统的演化，同时也要有一些细节来指导如何实现这些原则。对于一个足够小的群组，比如单个团队来说，将原则和实践进行结合是没问题的。但是在一个大型组织中，技术和工作实践可能不一样，在不同的地方需要的实践可能也不同。不过这也没关系，只要它们都能够映射到相同的原则即可。比如一个 .NET 团队可能有一套实践，一个 Java 团队有另一套实践，但背后的原则是相同的。\n# 5.要求的标准\n在优化单个服务自治性的同时，也要兼顾全局。一种能帮助我们实现平衡的方法就是，清楚地定义出一个好服务应有的属性。\n\n## 5.1监控\n能够清晰地描绘出跨服务系统的健康状态非常关键。这必须在系统级别而非单个服务级别进行考虑。简单起见，我建议确保所有的服务使用同样的方式报告健康状态及其与监控相关的数据。\n\n你可能会选择使用推送机制，也就是说，每个服务主动把数据推送到某个集中的位置。你可以使用 Graphite 来收集指标数据，使用 Nagios 来检测健康状态，或者使用轮询系统来从各个节点收集数据，但无论你的选择是什么，都应尽量保持标准化。每个服务内的技术应该对外不透明，并且不要为了服务的具体实现而改变监控系统。日志功能和监控情况类似：也需要集中式管理。\n## 5.2接口\n选用少数几种明确的接口技术有助于新消费者的集成。使用一种标准方式很好，两种也不太坏，但是 20 种不同的集成技术就太糟糕了。这里说的不仅仅是关于接口的技术和协议。举个例子，如果你选用了 HTTP/REST，在 URL 中你会使用动词还是名词？你会如何处理资源的分页？你会如何处理不同版本的 API ？\n## 5.3架构安全性\n一个运行异常的服务可能会毁了整个系统，而这种后果是我们无法承担的，所以，必须保证每个服务都可以应对下游服务的错误请求。没有很好处理下游错误请求的服务越多，我们的系统就会越脆弱。你可以至少让每个下游服务使用它们自己的连接池，进一步让每个服务使用一个断路器。\n\n# 6.代码治理\n聚在一起，就如何做事情达成共识是一个好主意。但是，花时间保证人们按照这个共识来做事情就没那么有趣了，因为在各个服务中使用这些标准做法会成为开发人员的负担。我坚信应该使用简单的方式把事情做对。我见过的比较奏效的两种方式是，提供范例和服务代码模板。\n## 6.1范例\n编写文档是有用的。我很清楚这样做的价值，这也正是我写这本书的原因。但是开发人员更喜欢可以查看和运行的代码。如果你有一些很好的实践希望别人采纳，那么给出一系列的代码范例会很有帮助。这样做的一个初衷是：如果在系统中人们有比较好的代码范例可以模仿，那么他们也就不会错得很离谱。\n\n理想情况下，你提供的优秀范例应该来自真实项目，而不是专门实现的一个完美的例子。因为如果你的范例来自真正运行的代码，那么就可以保证其中所体现的那些原则都是合理的。\n\n## 6.2裁剪服务代码模板\n如果能够让所有的开发人员很容易地遵守大部分的指导原则，那就太棒了。一种可能的方式是，当开发人员想要实现一个新服务时，所有实现核心属性的那些代码都应该是现成的。\n\n有一点需要注意的是，创建服务代码模板不是某个中心化工具的职责，也不是指导（即使是通过代码）我们应怎样工作的架构团队的职责。应该通过合作的方式定义出这些实践，所以你的团队也需要负责更新这个模板（内部开源的方式能够很好地完成这项工作）。\n\n如果你强制团队使用它，一定要确保它能够简化开发人员的工作，而不是使其复杂化。你还需要知道，重用代码可能引入的危险。在重用代码的驱动下，我们可能会引入服务之间的耦合。\n# 7.技术债务\n有时候可能无法完全遵守技术愿景，比如为了发布一些紧急的特性，你可能会忽略一些约束。其实这仅仅是另一个需要做的取舍而已。我们的技术愿景有其本身的道理，所以偏离了这个愿景短期可能会带来利益，但是长期来看是要付出代价的。可以使用技术债务的概念来帮助我们理解这个取舍，就像在真实世界中欠的债务需要偿还一样，累积的技术债务也是如此。\n\n不光走捷径会引入技术债务。有时候系统的目标会发生改变，并且与现有的实现不符，这种情况也会产生技术债务。\n\n架构师的职责就是从更高的层次出发，理解如何做权衡。理解债务的层次及其对系统的影响非常重要。对于某些组织来说，架构师应该能够提供一些温和的指导，然后让团队自行决定如何偿还这些技术债务。而其他的组织就需要更加结构化的方式，比如维护一个债务列表，并且定期回顾。\n# 8.例外管理\n原则和实践可以指导我们如何构建系统。那么，如果系统偏离了这些指导又会发生什么呢？有时候我们会决定针对某个规则破一次例，然后把它记录下来。\n\n现实中的情况是多种多样的，如果你所在的组织对开发人员有非常多的限制，那么微服务可能并不适合你。\n# 9.集中治理和领导\n架构师的部分职责是治理。那么治理又是什么意思呢？\n\n**治理通过评估干系人的需求、当前情况及下一步的可能性来确保企业目标的达成，通过排优先级和做决策来设定方向。对于已经达成一致的方向和目标进行监督。**\n\n在 IT 的上下文中有很多事情需要治理，而架构师会承担技术治理这部分的职责。如果说，架构师的一个职责是确保有一个技术愿景，那么治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。\n\n架构师会对很多事情负责。他们需要确保有一组可以指导开发的原则，并且这些原则要与组织的战略相符。他们还需要确保，以这些原则为指导衍生出来的实践不会给开发人员带来痛苦。他们需要了解新技术，需要知道在什么时候做怎样的取舍。上述这些职责已经相当多了，但是他们还需要让同事也理解这些决定和取舍，并执行下去。对了，还有前面提到的：他们还需要花时间和团队一起工作，甚至是编码，从而了解所做的决定对团队造成了怎样的影响。\n\n需要在一定程度上相信你的团队。你没法替代他们去骑车。你会看着他们摇摇晃晃地前行，但是，如果每次你看到他们要跌倒就上去扶一把，他们永远都学不会。而且无论如何，他们真正跌倒的次数会比你想象的要少！但是，如果他们马上就要驶入车流繁忙的大马路，或者附近的鸭子池塘，你就必须站出来了。类似地，作为一名架构师，你必须要在团队驶向类似鸭子池塘这样的地方时抓紧他们。还有一点要注意的是，即使你很清楚什么是对的，然后尝试去控制团队，也可能会破坏和团队的关系，并且会使团队感觉他们没有话语权。有时候按照一个你不同意的决定走下去反而是正确的，知道什么时候可以这么做，什么时候不要这么做是很困难的，但有时也很关键。\n\n# 10.建设团队\n对于一个系统技术愿景的主要负责人来说，执行愿景不仅仅等同于做技术决定，和你一起工作的那些人自然会做这些决定。对于技术领导人来说，更重要的事情是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。\n\n伟大的软件来自于伟大的人。所以如果你只担心技术问题，那么恐怕你看到的问题远远不及一半。\n\n# 总结\n\n总结一下，一个演进式架构师应该承担的职责。\n\n- 愿景\n\n确保在系统级有一个经过充分沟通的技术愿景，这个愿景应该可以帮助你满足客户和组织的需求。\n\n- 同理心\n\n理解你所做的决定对客户和同事带来的影响。\n\n- 合作\n\n和尽量多的同事进行沟通，从而更好地对愿景进行定义、修订及执行。\n\n- 适应性\n\n确保在你的客户和组织需要的时候调整技术愿景。\n\n- 自治性\n\n在标准化和团队自治之间寻找一个正确的平衡点。\n\n- 治理\n\n确保系统按照技术愿景的要求实现。\n\n演进式架构师应该理解，成功要靠不断地取舍来实现。总会存在一些原因需要你改变工作的方式，但是具体做哪些改变就只能依赖于自己的经验了。而僵化地固守自己的想法无疑是最糟糕的做法。","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"怎么做到服务的优雅上下线","url":"/2021/04/19/怎么做到服务的优雅上下线/","content":"在平常工作中，服务如果重启，怎么保证一个请求不会被中断处理的呢？\n也就是如何做到让服务优雅的上下线。\n<!--more-->\n# 什么是优雅上下线\n关于\"优雅上下线\"这个词，我没找到官方的解释，我尝试解释一下这是什么。\n首先，上线、下线大家一定都很清楚，比如我们一次应用发布过程中，就需要先将应用服务停掉，然后再把服务启动起来。这个过程就包含了一次下线和一次上线。\n那么，\"优雅\"怎么理解呢？\n先说什么情况我们认为不优雅：\n\n1、服务停止时，没有关闭对应的监控，导致应用停止后发生大量报警。\n\n2、应用停止时，没有通知外部调用方，很多请求还会过来，导致很多调用失败。\n\n3、应用停止时，有线程正在执行中，执行了一半，JVM进程就被干掉了。\n\n4、应用启动时，服务还没准备好，就开始对外提供服务，导致很多失败调用。\n\n5、应用启动时，没有检查应用的健康状态，就开始对外提供服务，导致很多失败调用。\n\n以上，都是我们认为的不优雅的情况，那么，反过来，优雅上下线就是一种避免上述情况发生的手段。\n一个应用的优雅上下线涉及到的内容其实有很多，从底层的操作系统、容器层面，到编程语言、框架层面，再到应用架构层面，涉及到的知识很广泛。\n\n其实，优雅上下线中，最重要的还是优雅下线。因为如果下线过程不优雅的话，就会发生很多调用失败了、服务找不到等问题。所以很多时候，大家也会提优雅停机这样的概念。\n\n本文后面介绍的优雅上下线也重点关注优雅停机的过程。\n# 操作系统&容器的优雅上下线\n我们知道，kill -9之所以不建议使用，是因为kill -9特别强硬，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。\n\n这个过程显然是不优雅的，因为应用立刻停止的话，就没办法做收尾动作。而更优雅的方式是kill -15。\n\n当使用kill -15时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。\n\nkill -15会通知到应用程序，这就是操作系统对于优雅上下线的最基本的支持。\n\n以前，在操作系统之上就是应用程序了，但是，自从容器化技术推出之后，在操作系统和应用程序之间，多了一个容器层，而Docker、k8s等容器其实也是支持优雅上下线的。\n\n如Docker中同样提供了两个命令， docker stop 和 docker kill\ndocker stop就像kill -15一样，他会向容器内的进程发送SIGTERM信号，在10S之后（可通过参数指定）再发送SIGKILL信号。\n\n而docker kill就像kill -9，直接发送SIGKILL信号。\n# JVM的优雅上下线\n在操作系统、容器等对优雅上下线有了基本的支持之后，在接收到docker stop、kill -15等命令后，会通知应用进程进行进程关闭。\n\n而Java应用在运行时就是一个独立运行的进程，这个进程是如何关闭的呢？\n\nJava程序的终止运行是基于JVM的关闭实现的，JVM关闭方式分为正常关闭、强制关闭和异常关闭3种。\n\n这其中，正常关闭就是支持优雅上下线的。正常关闭过程中，JVM可以做一些清理动作，比如删除临时文件。\n\n当然，开发者也是可以自定义做一些额外的事情的，比如通知应用框架优雅上下线操作。\n\n而这种机制是通过JDK中提供的shutdown hook实现的。JDK提供了Java.Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的钩子。\n\n例子如下：\n\n```\npackage com.test;\n\n    public class ShutdownHookTest {\n\n        public static void main(String[] args) {\n\n            boolean flag = true;\n\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n\n                System.out.println(\"hook execute...\");\n\n            }));\n\n            while (flag) {\n\n                // app is runing\n\n            }\n\n            System.out.println(\"main thread execute end...\");\n\n        }\n\n    }\n\n```\n执行命令：\n\n```\njps\n 6520 ShutdownHookTest\n 6521 Jps\nkill 6520\n```\n控制台输出内容：\n\n```\n hook execute...\n\n Process finished with exit code 143 (interrupted by signal 15: SIGTERM)\n```\n可以看到，当我们使用kill（默认kill -15）关闭进程的时候，程序会先执行我注册的shutdownHook，然后再退出，并且会给出一个提示：interrupted by signal 15: SIGTERM\n# Spring的优雅上下线\n有了JVM提供的shutdown hook之后，很多框架都可以通过这个机制来做优雅下线的支持。\n比如Spring，他就会向JVM注册一个shutdown hook，在接收到关闭通知的时候，进行bean的销毁，容器的销毁处理等操作。\n同时，作为一个成熟的框架，Spring也提供了事件机制，可以借助这个机制实现更多的优雅上下线功能。\nApplicationListener是Spring事件机制的一部分，与抽象类ApplicationEvent类配合来完成ApplicationContext的事件机制。\n开发者可以实现ApplicationListener接口，监听到 Spring 容器的关闭事件（ContextClosedEvent），来做一些特殊的处理：\n\n```\n@Component\n\n    public class MyListener implements ApplicationListener<ContextClosedEvent> {\n\n        @Override\n\n        public void onApplicationEvent(ContextClosedEvent event) {\n\n            // 做容器关闭之前的清理工作\n\n        }\n\n    }\n```\n# Dubbo的优雅上下线\n因为Spring中提供了ApplicationListener接口，帮助我们来监听容器关闭事件，那么，很多web容器、框架等就可以借助这个机制来做自己的优雅上下线操作。\n如tomcat、dubbo等都是这么做的。\n这里简答说一下Dubbo的，在Dubbo的官网中，有关于优雅停机的介绍：\n![WechatIMG188.jpeg](https://i.loli.net/2021/04/19/5nRCTzufWOiSKYU.jpg)\n应用在停机时，接收到关闭通知时，会先把自己标记为不接受（发起）新请求，然后再等待10s（默认是10秒）的时候，等执行中的线程执行完。\n\n那么，之所以他能做这些事，是因为从操作系统、到JVM、到Spring等都对优雅停机做了很好的支持。\n\n目前，Dubbo中实现方式如下，同样是用到了Spring的事件机制：\n\n```\npublic class SpringExtensionFactory implements ExtensionFactory {\n\n        public static void addApplicationContext(ApplicationContext context) {\n\n            CONTEXTS.add(context);\n\n            if (context instanceof ConfigurableApplicationContext) {\n\n                ((ConfigurableApplicationContext) context).registerShutdownHook();\n\n                DubboShutdownHook.getDubboShutdownHook().unregister();\n\n            }\n\n            BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);\n\n        }\n\n    }\n```\n# 总结\n本文从操作系统开始，分别介绍了Linux、Docker、JVM、Spring、Dubbo等对优雅停机的支持。\n可以看到，一个简单的优雅停机功能，上下游需要这么多底层基础设施和上层应用的支持。\n相信通过学习本文，你一定对优雅上下线有了更多的了解。\n除此之外，我还希望你，通过本文以后，遇到一些实际问题的时候，可以想到文中提到的shutdown hook机制、Spring的event机制。很多时候，这些机制都能帮助我们解决很多问题。\n\n参考：\n\nhttps://mp.weixin.qq.com/s/qBKaRt34zeSI0OzBEAnu7g\n\nhttps://zhuanlan.zhihu.com/p/29093407\n\nhttps://www.cnkirito.moe/dubbo-gracefully-shutdown/\n\nhttps://www.cnkirito.moe/dubbo-gracefully-shutdown/\n","tags":["部署","技能包"],"categories":["技能包"]},{"title":"《微服务设计》第1章 微服务","url":"/2021/04/18/微服务设计1/","content":"最近在重读《微服务设计》这本书，我会输出我认为的精华部分所在，希望自己能有更多的总结领悟和思想碰撞，从而提升自己。重新审视微服务该如何设计。开始吧：\n<!--more-->\n# 1.什么是微服务\n微服务就是一些协同工作的小而自治的服务。\n## 1.1 很小，专注于做好一件事\n随着新功能的增加，代码库会越变越大。时间久了代码库会越来越庞大，以至于想要知道应该在什么地方做修改都很困难。尽管我们想在巨大的代码库中做到清晰地模块化，但事实上这些模块之间的界限很难维护。相似的功能代码开始在代码库中随处可见，这让修复bug和修改原有实现更加困难。\n微服务将内聚性这个理念应用在独立的服务上。根据业务的边界来确定服务的边界，这样就很容易确定某个功能代码应该放在哪里。由于该服务专注于某个边界之内，因此可以很好地避免由于代码库过大而衍生出来的很多让人头痛的问题。\n那么代码库多小才算小？作者给出的一个比较老套的方案是：足够小即可，不要过小。那么换句话说，如果你不再感觉你的代码库过大，可能他就足够小了。还有一点就是该服务是否能够很好的与团队结构相匹配。\n服务越小，微服务架构的优点和缺点也就越明显。使用的服务越小，独立性带来的好处就越多。但是管理大量服务带来的复杂性也会越来越大。\n如果你能够很好的处理这一复杂性，那就可以尽情地使用较小的服务了。\n## 1.2 自治性\n一个微服务就是一个独立的实体。它可以独立地部署在PAAS上，也可以作为一个操作系统的进程存在。我们要尽量避免把多个服务部署在同一台机器上，尽管这种隔离性会带来一些代价。\n服务直接均通过网络调用进行通信，从而加强了服务直接的隔离性，避免紧耦合。\n这些服务应该可以彼此间独立进行修改，对于一个服务来说，我们应该考虑暴露应该暴露的部分，如果暴露过多服务消费方和提供方就会产生耦合。这回使得服务提供方和消费方直接产生额外的协调工作，从而降低服务的自治性。\n服务提供者会暴露出API，然后服务之间通过这些API进行通信。如果系统没有很好地进行解耦，那么一旦出现问题，所有的功能都将不可用。\n# 2.微服务的主要好处\n## 2.1 技术异构性\n在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。尝试使用一种适合所有场景的标准化技术，会使得所有的场景都无法得到很好的支持。\n微服务可以帮助我们轻松地采用不同的技术：\n![WechatIMG186.png](https://i.loli.net/2021/04/18/LDNp6jw9mdAUuGB.png)\n## 2.2 弹性\n弹性工程学的一个关键概念是舱壁虎。其实服务边界就是一个很显然的舱壁。微服务可以改进弹性，但你还是需要谨慎对待，因为一旦使用了分布式系统，网络就是个问题，机器也是个问题。因此我们需要了解出现问题时应该如何对用户进行友好展示。\n## 2.3 扩展\n庞大的单体服务只能作为一个整体进行扩展。即使系统中只有一部分存在性能问题，也需要对整个服务进行扩展。如果使用较小的服务，则可以选择只对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在性能更差的硬件上从而节省成本。\n![WechatIMG10455.png](https://i.loli.net/2021/04/18/29HVyxR1jODXJpM.png)\n## 2.4 简化部署\n在几百万代码行的单体应用程序中，即使你只修改了一行代码，也要重新部署整个服务发布该变更。\n在微服务架构中，各个服务的部署是独立的，这样就能更快的对特定部分的代码进行部署。如果真的出了问题，也只会影响一个服务，并且容易快速回滚。\n## 2.5 与组织架构相匹配\n微服务架构可以将架构和组织结构相匹配，避免出现过大的代码库，从而获得理想的团队大小和生产力。服务的所有权也可以在团队直接迁移，从而避免异地团队的出现。\n## 2.6 可组合性\n在微服务架构中，系统会开放很多接口供外部使用。而单体应用只能提供一个非常粗粒度的接口供外部使用。所以微服务架构可以达到可重用，可组合的目的。\n## 对可代替性的优化\n想想看，在一个庞大的单体应用中你敢不敢在一天内删掉上百行代码，并且确性不会引发问题。所以使用微服务架构的团队可以在需要时轻易地重写服务，或者删除不再使用的服务。\n# 3.面向服务的架构\nSOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列的功能。SOA本身是一个很好的想法，但尽管做了很多尝试，人们还是无法在如何做好SOA这件事情上达成共识。因为业界大部分的尝试都没能把它当作一个整体来看待，因此很难给出一个比该领域现有厂家提供的方案更好呢替代方案，也就是没有对应的标准和方法论。所以在实施SOA时会遇到一些问题：通信协议如何选择、第三方中间件如何选择、服务粒度如何确定等。而这事实上就是微服务架构，你也可以认为微服务架构是SOA的一种特定方法。\n# 4.没有银弹\n软件工程没有银弹，微服务也是如此，它不是免费的午餐，更不是银弹。选择微服务的同时，你需要在部署、测试、监控等方面做很多的工作，你还需要考虑如何扩展系统，并且保证他们的弹性，还需要处理分布式事务与CAP相关的问题。\n每个公司、组织及系统都不一样。微服务是否适合你，或者说你能够在多大的程度上采用微服务，取决于很多因素。\n\n架构师承担了驱动系统演化的职责，而引入微服务之后的一个主要挑战就是，架构师职责的相应变化。下一章会讲到有哪些方法可以保证我们从这个新架构中受益。\n\n\n","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"安装bamboo，使用postgresql存储数据","url":"/2021/04/16/安装bamboo/","content":"\n# 1、编辑dockerfile 文件\n\n```\nFROM atlassian/bamboo-server:7.2.1\n\nUSER root\n```\n<!--more-->\n# 2、将代理破解包加入容器\n\n```\nCOPY \"atlassian-agent.jar\" /opt/atlassian/bamboo/\nCOPY \"mysql-connector-java-8.0.18.jar\" /opt/atlassian/bamboo/lib/\n```\n\n# 3、设置启动加载代理包\n\n```\nRUN echo 'export CATALINA_OPTS=\"-javaagent:/opt/atlassian/bamboo/atlassian-agent.jar ${CATALINA_OPTS}\"' >> /opt/atlassian/bamboo/bin/setenv.sh\n```\n\n\n# 4、编译dockerfile文件，生成镜像\n\n```\ndocker build -t hl/bamboo:7.2.1\n```\n\n# 5、运行容器\n\n```\ndocker run -d --name hl-bamboo \\\n--restart always \\\n-p 8085:8085 \\\n-p 54663:54663 \\\n-e TZ=\"Asia/Shanghai\" \\\n-v /home/atlassian/bamboo/data:/var/atlassian/application-data/bamboo \\\n-v /home/atlassian/bamboo/settings.xml:/opt/maven/settings.xml \\\nhl/bamboo:7.2.1\n```\n\n\n# 6、破解\n\n```\njava -jar atlassian-agent.jar -d -m bamboo@guwenxiang.com -n bamboo -p bamboo -o http://47.28.176.98 -s xxxx-xxxx-xxxx\n```\n","tags":["linux"],"categories":["服务器","bamboo"]},{"title":"我的概要设计思路","url":"/2021/04/16/我的概要设计思路/","content":"如下：\n<!--more-->\n![我的概要设计思路.png](https://i.loli.net/2021/04/16/1bIT79ZoDFnUeBO.png)","tags":["项目管理","概要设计"],"categories":["项目管理","概要设计"]},{"title":"我的想法","url":"/2021/04/15/开始/","content":"\n从去年开始，我有一种很明显的感觉：时不我待。\n<!--more-->\n\n一方面因为自己的年龄，一方面是技术的广度和深度都不足以让我游刃有余。\n说白了就是我的能力支撑不了我的野心。\n\n回想起工作的前三年其实我非常荒废，不思进取。经常间歇性踌躇满志，持续性混吃等死。所以现在的处境，焦虑感也就油然而生。\n\n于是我主动地让自己开始学习起来，我经常看一些互联网大佬的技术文章、逛各种技术论坛，知道的越多，发现自己不知道的也就越多。\n\n我逐渐意识到基础的重要性，技术基础好比内力，内力高深，学什么都快，同样的招式，内力高深的人显然更胜一筹。\n\n后面我会在这里，写一些自己的东西，或者是摘抄我认为对我有帮助的技术大牛的文章(毕竟自己写是很费时间的，拿来主义)\n\n写博客主要还是写给自己看的，因为我记性不太好，怕自己忘掉。方便我以后查阅，或者我自己也懒得看。但是这都不要紧，写下来就不会丢。\n\n借用王安石的《游褒禅山记》激励自己吧：夫夷以近，则游者众；险以远，则至者少；而世之奇伟瑰怪非常之观，常在于险远而人之所罕至焉，故非有志者不能至也。\n\n我记得大狗有句台词，我就是做狗也要做专家狗[大笑]\n\n最后希望自己能持续学习，不断实践。个人能力螺旋式上升，变强就行了，拒绝变秃。\n![WechatIMG189.jpeg](https://i.loli.net/2021/04/19/E7eh1kNU4JnWqtx.jpg)\n","tags":["生活"],"categories":["生活"]}]