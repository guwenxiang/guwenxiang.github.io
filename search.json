[{"title":"怎么做到服务的优雅上下线","url":"/2021/04/19/怎么做到服务的优雅上下线/","content":"在平常工作中，服务如果重启，怎么保证一个请求不会被中断处理的呢？\n也就是如何做到让服务优雅的上下线。\n<!--more-->\n# 什么是优雅上下线\n关于\"优雅上下线\"这个词，我没找到官方的解释，我尝试解释一下这是什么。\n首先，上线、下线大家一定都很清楚，比如我们一次应用发布过程中，就需要先将应用服务停掉，然后再把服务启动起来。这个过程就包含了一次下线和一次上线。\n那么，\"优雅\"怎么理解呢？\n先说什么情况我们认为不优雅：\n\n1、服务停止时，没有关闭对应的监控，导致应用停止后发生大量报警。\n\n2、应用停止时，没有通知外部调用方，很多请求还会过来，导致很多调用失败。\n\n3、应用停止时，有线程正在执行中，执行了一半，JVM进程就被干掉了。\n\n4、应用启动时，服务还没准备好，就开始对外提供服务，导致很多失败调用。\n\n5、应用启动时，没有检查应用的健康状态，就开始对外提供服务，导致很多失败调用。\n\n以上，都是我们认为的不优雅的情况，那么，反过来，优雅上下线就是一种避免上述情况发生的手段。\n一个应用的优雅上下线涉及到的内容其实有很多，从底层的操作系统、容器层面，到编程语言、框架层面，再到应用架构层面，涉及到的知识很广泛。\n\n其实，优雅上下线中，最重要的还是优雅下线。因为如果下线过程不优雅的话，就会发生很多调用失败了、服务找不到等问题。所以很多时候，大家也会提优雅停机这样的概念。\n\n本文后面介绍的优雅上下线也重点关注优雅停机的过程。\n# 操作系统&容器的优雅上下线\n我们知道，kill -9之所以不建议使用，是因为kill -9特别强硬，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。\n\n这个过程显然是不优雅的，因为应用立刻停止的话，就没办法做收尾动作。而更优雅的方式是kill -15。\n\n当使用kill -15时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。\n\nkill -15会通知到应用程序，这就是操作系统对于优雅上下线的最基本的支持。\n\n以前，在操作系统之上就是应用程序了，但是，自从容器化技术推出之后，在操作系统和应用程序之间，多了一个容器层，而Docker、k8s等容器其实也是支持优雅上下线的。\n\n如Docker中同样提供了两个命令， docker stop 和 docker kill\ndocker stop就像kill -15一样，他会向容器内的进程发送SIGTERM信号，在10S之后（可通过参数指定）再发送SIGKILL信号。\n\n而docker kill就像kill -9，直接发送SIGKILL信号。\n# JVM的优雅上下线\n在操作系统、容器等对优雅上下线有了基本的支持之后，在接收到docker stop、kill -15等命令后，会通知应用进程进行进程关闭。\n\n而Java应用在运行时就是一个独立运行的进程，这个进程是如何关闭的呢？\n\nJava程序的终止运行是基于JVM的关闭实现的，JVM关闭方式分为正常关闭、强制关闭和异常关闭3种。\n\n这其中，正常关闭就是支持优雅上下线的。正常关闭过程中，JVM可以做一些清理动作，比如删除临时文件。\n\n当然，开发者也是可以自定义做一些额外的事情的，比如通知应用框架优雅上下线操作。\n\n而这种机制是通过JDK中提供的shutdown hook实现的。JDK提供了Java.Runtime.addShutdownHook(Thread hook)方法，可以注册一个JVM关闭的钩子。\n\n例子如下：\n\n```\npackage com.test;\n\n    public class ShutdownHookTest {\n\n        public static void main(String[] args) {\n\n            boolean flag = true;\n\n            Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n\n                System.out.println(\"hook execute...\");\n\n            }));\n\n            while (flag) {\n\n                // app is runing\n\n            }\n\n            System.out.println(\"main thread execute end...\");\n\n        }\n\n    }\n\n```\n执行命令：\n\n```\njps\n 6520 ShutdownHookTest\n 6521 Jps\nkill 6520\n```\n控制台输出内容：\n\n```\n hook execute...\n\n Process finished with exit code 143 (interrupted by signal 15: SIGTERM)\n```\n可以看到，当我们使用kill（默认kill -15）关闭进程的时候，程序会先执行我注册的shutdownHook，然后再退出，并且会给出一个提示：interrupted by signal 15: SIGTERM\n# Spring的优雅上下线\n有了JVM提供的shutdown hook之后，很多框架都可以通过这个机制来做优雅下线的支持。\n比如Spring，他就会向JVM注册一个shutdown hook，在接收到关闭通知的时候，进行bean的销毁，容器的销毁处理等操作。\n同时，作为一个成熟的框架，Spring也提供了事件机制，可以借助这个机制实现更多的优雅上下线功能。\nApplicationListener是Spring事件机制的一部分，与抽象类ApplicationEvent类配合来完成ApplicationContext的事件机制。\n开发者可以实现ApplicationListener接口，监听到 Spring 容器的关闭事件（ContextClosedEvent），来做一些特殊的处理：\n\n```\n@Component\n\n    public class MyListener implements ApplicationListener<ContextClosedEvent> {\n\n        @Override\n\n        public void onApplicationEvent(ContextClosedEvent event) {\n\n            // 做容器关闭之前的清理工作\n\n        }\n\n    }\n```\n# Dubbo的优雅上下线\n因为Spring中提供了ApplicationListener接口，帮助我们来监听容器关闭事件，那么，很多web容器、框架等就可以借助这个机制来做自己的优雅上下线操作。\n如tomcat、dubbo等都是这么做的。\n这里简答说一下Dubbo的，在Dubbo的官网中，有关于优雅停机的介绍：\n![WechatIMG188.jpeg](https://i.loli.net/2021/04/19/5nRCTzufWOiSKYU.jpg)\n应用在停机时，接收到关闭通知时，会先把自己标记为不接受（发起）新请求，然后再等待10s（默认是10秒）的时候，等执行中的线程执行完。\n\n那么，之所以他能做这些事，是因为从操作系统、到JVM、到Spring等都对优雅停机做了很好的支持。\n\n目前，Dubbo中实现方式如下，同样是用到了Spring的事件机制：\n\n```\npublic class SpringExtensionFactory implements ExtensionFactory {\n\n        public static void addApplicationContext(ApplicationContext context) {\n\n            CONTEXTS.add(context);\n\n            if (context instanceof ConfigurableApplicationContext) {\n\n                ((ConfigurableApplicationContext) context).registerShutdownHook();\n\n                DubboShutdownHook.getDubboShutdownHook().unregister();\n\n            }\n\n            BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);\n\n        }\n\n    }\n```\n# 总结\n本文从操作系统开始，分别介绍了Linux、Docker、JVM、Spring、Dubbo等对优雅停机的支持。\n可以看到，一个简单的优雅停机功能，上下游需要这么多底层基础设施和上层应用的支持。\n相信通过学习本文，你一定对优雅上下线有了更多的了解。\n除此之外，我还希望你，通过本文以后，遇到一些实际问题的时候，可以想到文中提到的shutdown hook机制、Spring的event机制。很多时候，这些机制都能帮助我们解决很多问题。\n\n参考：\n\nhttps://mp.weixin.qq.com/s/qBKaRt34zeSI0OzBEAnu7g\n\nhttps://zhuanlan.zhihu.com/p/29093407\n\nhttps://www.cnkirito.moe/dubbo-gracefully-shutdown/\n\nhttps://www.cnkirito.moe/dubbo-gracefully-shutdown/\n","tags":["部署","技能包"],"categories":["技能包"]},{"title":"《微服务设计》第一章 微服务","url":"/2021/04/18/微服务设计1/","content":"最近在重读《微服务设计》这本书，我会输出我认为的精华部分所在，希望自己能有更多的总结领悟和思想碰撞，从而提升自己。重新审视微服务该如何设计。开始吧：\n<!--more-->\n# 1.什么是微服务\n微服务就是一些协同工作的小而自治的服务。\n## 1.1 很小，专注于做好一件事\n随着新功能的增加，代码库会越变越大。时间久了代码库会越来越庞大，以至于想要知道应该在什么地方做修改都很困难。尽管我们想在巨大的代码库中做到清晰地模块化，但事实上这些模块之间的界限很难维护。相似的功能代码开始在代码库中随处可见，这让修复bug和修改原有实现更加困难。\n微服务将内聚性这个理念应用在独立的服务上。根据业务的边界来确定服务的边界，这样就很容易确定某个功能代码应该放在哪里。由于该服务专注于某个边界之内，因此可以很好地避免由于代码库过大而衍生出来的很多让人头痛的问题。\n那么代码库多小才算小？作者给出的一个比较老套的方案是：足够小即可，不要过小。那么换句话说，如果你不再感觉你的代码库过大，可能他就足够小了。还有一点就是该服务是否能够很好的与团队结构相匹配。\n服务越小，微服务架构的优点和缺点也就越明显。使用的服务越小，独立性带来的好处就越多。但是管理大量服务带来的复杂性也会越来越大。\n如果你能够很好的处理这一复杂性，那就可以尽情地使用较小的服务了。\n## 1.2 自治性\n一个微服务就是一个独立的实体。它可以独立地部署在PAAS上，也可以作为一个操作系统的进程存在。我们要尽量避免把多个服务部署在同一台机器上，尽管这种隔离性会带来一些代价。\n服务直接均通过网络调用进行通信，从而加强了服务直接的隔离性，避免紧耦合。\n这些服务应该可以彼此间独立进行修改，对于一个服务来说，我们应该考虑暴露应该暴露的部分，如果暴露过多服务消费方和提供方就会产生耦合。这回使得服务提供方和消费方直接产生额外的协调工作，从而降低服务的自治性。\n服务提供者会暴露出API，然后服务之间通过这些API进行通信。如果系统没有很好地进行解耦，那么一旦出现问题，所有的功能都将不可用。\n# 2.微服务的主要好处\n## 2.1 技术异构性\n在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。尝试使用一种适合所有场景的标准化技术，会使得所有的场景都无法得到很好的支持。\n微服务可以帮助我们轻松地采用不同的技术：\n![WechatIMG186.png](https://i.loli.net/2021/04/18/LDNp6jw9mdAUuGB.png)\n## 2.2 弹性\n弹性工程学的一个关键概念是舱壁虎。其实服务边界就是一个很显然的舱壁。微服务可以改进弹性，但你还是需要谨慎对待，因为一旦使用了分布式系统，网络就是个问题，机器也是个问题。因此我们需要了解出现问题时应该如何对用户进行友好展示。\n## 2.3 扩展\n庞大的单体服务只能作为一个整体进行扩展。即使系统中只有一部分存在性能问题，也需要对整个服务进行扩展。如果使用较小的服务，则可以选择只对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在性能更差的硬件上从而节省成本。\n![WechatIMG10455.png](https://i.loli.net/2021/04/18/29HVyxR1jODXJpM.png)\n## 2.4 简化部署\n在几百万代码行的单体应用程序中，即使你只修改了一行代码，也要重新部署整个服务发布该变更。\n在微服务架构中，各个服务的部署是独立的，这样就能更快的对特定部分的代码进行部署。如果真的出了问题，也只会影响一个服务，并且容易快速回滚。\n## 2.5 与组织架构相匹配\n微服务架构可以将架构和组织结构相匹配，避免出现过大的代码库，从而获得理想的团队大小和生产力。服务的所有权也可以在团队直接迁移，从而避免异地团队的出现。\n## 2.6 可组合性\n在微服务架构中，系统会开放很多接口供外部使用。而单体应用只能提供一个非常粗粒度的接口供外部使用。所以微服务架构可以达到可重用，可组合的目的。\n## 对可代替性的优化\n想想看，在一个庞大的单体应用中你敢不敢在一天内删掉上百行代码，并且确性不会引发问题。所以使用微服务架构的团队可以在需要时轻易地重写服务，或者删除不再使用的服务。\n# 3.面向服务的架构\nSOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列的功能。SOA本身是一个很好的想法，但尽管做了很多尝试，人们还是无法在如何做好SOA这件事情上达成共识。因为业界大部分的尝试都没能把它当作一个整体来看待，因此很难给出一个比该领域现有厂家提供的方案更好呢替代方案，也就是没有对应的标准和方法论。所以在实施SOA时会遇到一些问题：通信协议如何选择、第三方中间件如何选择、服务粒度如何确定等。而这事实上就是微服务架构，你也可以认为微服务架构是SOA的一种特定方法。\n# 4.没有银弹\n软件工程没有银弹，微服务也是如此，它不是免费的午餐，更不是银弹。选择微服务的同时，你需要在部署、测试、监控等方面做很多的工作，你还需要考虑如何扩展系统，并且保证他们的弹性，还需要处理分布式事务与CAP相关的问题。\n每个公司、组织及系统都不一样。微服务是否适合你，或者说你能够在多大的程度上采用微服务，取决于很多因素。\n\n架构师承担了驱动系统演化的职责，而引入微服务之后的一个主要挑战就是，架构师职责的相应变化。下一章会讲到有哪些方法可以保证我们从这个新架构中受益。\n\n\n","tags":["微服务","架构"],"categories":["架构探险","微服务设计"]},{"title":"安装bamboo，使用postgresql存储数据","url":"/2021/04/16/安装bamboo/","content":"\n# 1、编辑dockerfile 文件\n\n```\nFROM atlassian/bamboo-server:7.2.1\n\nUSER root\n```\n<!--more-->\n# 2、将代理破解包加入容器\n\n```\nCOPY \"atlassian-agent.jar\" /opt/atlassian/bamboo/\nCOPY \"mysql-connector-java-8.0.18.jar\" /opt/atlassian/bamboo/lib/\n```\n\n# 3、设置启动加载代理包\n\n```\nRUN echo 'export CATALINA_OPTS=\"-javaagent:/opt/atlassian/bamboo/atlassian-agent.jar ${CATALINA_OPTS}\"' >> /opt/atlassian/bamboo/bin/setenv.sh\n```\n\n\n# 4、编译dockerfile文件，生成镜像\n\n```\ndocker build -t hl/bamboo:7.2.1\n```\n\n# 5、运行容器\n\n```\ndocker run -d --name hl-bamboo \\\n--restart always \\\n-p 8085:8085 \\\n-p 54663:54663 \\\n-e TZ=\"Asia/Shanghai\" \\\n-v /home/atlassian/bamboo/data:/var/atlassian/application-data/bamboo \\\n-v /home/atlassian/bamboo/settings.xml:/opt/maven/settings.xml \\\nhl/bamboo:7.2.1\n```\n\n\n# 6、破解\n\n```\njava -jar atlassian-agent.jar -d -m bamboo@guwenxiang.com -n bamboo -p bamboo -o http://47.28.176.98 -s xxxx-xxxx-xxxx\n```\n","tags":["linux"],"categories":["服务器","bamboo"]},{"title":"我的概要设计思路","url":"/2021/04/16/我的概要设计思路/","content":"如下：\n<!--more-->\n![我的概要设计思路.png](https://i.loli.net/2021/04/16/1bIT79ZoDFnUeBO.png)","tags":["项目管理","概要设计"],"categories":["项目管理","概要设计"]},{"title":"我的想法","url":"/2021/04/15/开始/","content":"\n从去年开始，我有一种很明显的感觉：时不我待。\n<!--more-->\n\n一方面因为自己的年龄，一方面是技术的广度和深度都不足以让我游刃有余。\n说白了就是我的能力支撑不了我的野心。\n\n回想起工作的前三年其实我非常荒废，不思进取。经常间歇性踌躇满志，持续性混吃等死。所以现在的处境，焦虑感也就油然而生。\n\n于是我主动地让自己开始学习起来，我经常看一些互联网大佬的技术文章、逛各种技术论坛，知道的越多，发现自己不知道的也就越多。\n\n我逐渐意识到基础的重要性，技术基础好比内力，内力高深，学什么都快，同样的招式，内力高深的人显然更胜一筹。\n\n后面我会在这里，写一些自己的东西，或者是摘抄我认为对我有帮助的技术大牛的文章(毕竟自己写是很费时间的，拿来主义)\n\n写博客主要还是写给自己看的，因为我记性不太好，怕自己忘掉。方便我以后查阅，或者我自己也懒得看。但是这都不要紧，写下来就不会丢。\n\n借用王安石的《游褒禅山记》激励自己吧：夫夷以近，则游者众；险以远，则至者少；而世之奇伟瑰怪非常之观，常在于险远而人之所罕至焉，故非有志者不能至也。\n\n我记得大狗有句台词，我就是做狗也要做专家狗[大笑]\n\n最后希望自己能持续学习，不断实践。个人能力螺旋式上升，变强就行了，拒绝变秃。\n![WechatIMG189.jpeg](https://i.loli.net/2021/04/19/E7eh1kNU4JnWqtx.jpg)\n","tags":["生活"],"categories":["生活"]}]